<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Welcome To My Learning Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Welcome To My Learning Blog">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Welcome To My Learning Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="jianjian">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
          <a class="main-nav-link" href="/categories">分类</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Welcome To My Learning Blog</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-剑指13-机器人的运动范围" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/09/%E5%89%91%E6%8C%8713-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/" class="article-date">
  <time datetime="2021-03-09T02:53:13.000Z" itemprop="datePublished">2021-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/">力扣刷题</a>►<a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/%E5%9B%9E%E6%BA%AF%E6%B3%95/">回溯法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/09/%E5%89%91%E6%8C%8713-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/">剑指13-机器人的运动范围</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/">剑指13-机器人的运动范围</a></p>
<p>地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m &#x3D; 2, n &#x3D; 3, k &#x3D; 1</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number&#125; m</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @param &#123;number&#125; k</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var movingCount &#x3D; function(m, n, k) &#123;</span><br><span class="line">    let count &#x3D; 0;</span><br><span class="line">    let hasVisited &#x3D; new Array(m);</span><br><span class="line">    for(let i &#x3D; 0;i &lt; n;i++)&#123;</span><br><span class="line">        hasVisited[i] &#x3D; new Array(n).fill(false)</span><br><span class="line">    &#125;;</span><br><span class="line">    const dfs &#x3D; function(i,j)&#123;</span><br><span class="line">        if(i &lt; 0 || j &lt; 0 || i &gt;&#x3D; m|| j &gt;&#x3D; n)&#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;;</span><br><span class="line">        let sum &#x3D; (i+&#39;&#39;+j).split(&#39;&#39;).reduce((a,b)&#x3D;&gt;&#123;return Number(a) + Number(b)&#125;);</span><br><span class="line">        if(hasVisited[i][j] &#x3D;&#x3D; false &amp;&amp; sum &lt;&#x3D; k)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            hasVisited[i][j] &#x3D; true;</span><br><span class="line">            dfs(i-1,j);</span><br><span class="line">            dfs(i+1,j);</span><br><span class="line">            dfs(i,j-1);</span><br><span class="line">            dfs(i,j+1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs(0,0);</span><br><span class="line">    return count</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/09/%E5%89%91%E6%8C%8713-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/" data-id="ckmjwjiwr00091ktj29pphqwy" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-力扣1047-删除字符串中的相邻重复项" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/09/%E5%8A%9B%E6%89%A31047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/" class="article-date">
  <time datetime="2021-03-09T00:45:53.000Z" itemprop="datePublished">2021-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/">力扣刷题</a>►<a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/">栈和队列</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/09/%E5%8A%9B%E6%89%A31047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/">力扣1047--删除字符串中的相邻重复项</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">力扣1047–删除字符串中的相邻重复项</a></p>
<p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。<br>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;abbaca&quot;</span><br><span class="line">输出：&quot;ca&quot;</span><br><span class="line">解释：</span><br><span class="line">例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</span><br></pre></td></tr></table></figure>
<p>代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; S</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var removeDuplicates &#x3D; function(S) &#123;</span><br><span class="line">    &#x2F;&#x2F;利用栈先进后出的特性</span><br><span class="line">    let stack &#x3D; [];</span><br><span class="line">    for(let ch of S)&#123;</span><br><span class="line">        if(stack.length &amp;&amp; stack[stack.length-1] &#x3D;&#x3D;&#x3D; ch)&#123;</span><br><span class="line">            stack.pop()</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            stack.push(ch)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return stack.join(&#39;&#39;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/09/%E5%8A%9B%E6%89%A31047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/" data-id="ckmjwjix9001c1ktj6bwp4qe1" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-打通call、apply、bind" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/08/%E6%89%93%E9%80%9Acall%E3%80%81apply%E3%80%81bind/" class="article-date">
  <time datetime="2021-03-08T06:24:31.000Z" itemprop="datePublished">2021-03-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>►<a class="article-category-link" href="/categories/JavaScript/%E5%87%BD%E6%95%B0/">函数</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/08/%E6%89%93%E9%80%9Acall%E3%80%81apply%E3%80%81bind/">call、apply、bind的区别与实现</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>&emsp;&emsp;简单概括apply、bind、call的区别：他们都是用来改变相关函数this指向的，但是apply、call是直接进行相关函数调用的，bind不会执行相关函数，而是返回一个新的函数，这个新的函数已经自动绑定了新的this指向。call与apply之间的区别主要是在参数设定上。<br>&emsp;&emsp;call()与bind()接受的参数相同，第一个参数表示要改变的函数执行主体，即this的指向，从第二个参数到最后一个参数表示的是函数接受的参数，对于apply()函数来讲，第一个参数相同，第二个参数是一个数组，表示的是接受的所有参数。    </p>
<h3 id="call-方法的实现"><a href="#call-方法的实现" class="headerlink" title="call()方法的实现"></a>call()方法的实现</h3><p>原理：1）将函数设为对象的属性<br>&emsp;&emsp;2)执行和删除这个函数<br>&emsp;&emsp;3)指定 this 到函数并传入给定参数执行函数.如果不传参数，默认指向 window。  </p>
<p>call()实现代码及注释如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var name &#x3D; &#39;maomao&#39;;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    name:&#39;gougou&#39;</span><br><span class="line">&#125;;</span><br><span class="line">function fn(a,b,c)&#123;</span><br><span class="line">    console.log(a+b+c+this.name)</span><br><span class="line">&#125;</span><br><span class="line">Function.prototype.call1 &#x3D; function(obj)&#123;</span><br><span class="line">    &#x2F;&#x2F;判断是否为null或者undefined,同时考虑传递参数不是对象情况</span><br><span class="line">    obj &#x3D; obj ? Object(obj):window;</span><br><span class="line">    obj.fn &#x3D; this;</span><br><span class="line">    &#x2F;&#x2F; 利用拓展运算符直接将arguments转为数组</span><br><span class="line">    let args &#x3D; [...arguments].slice(1);</span><br><span class="line">    let result &#x3D; obj.fn(...args);</span><br><span class="line">    delete obj.fn;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.call1(obj,&#39;我的&#39;,&#39;宠物&#39;,&#39;是&#39;)</span><br></pre></td></tr></table></figure>
<p>apply实现及代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> Function.prototype.apply_ &#x3D; function(obj,arr)&#123;</span><br><span class="line">    obj &#x3D;&#x3D; obj? Object(obj) : window;</span><br><span class="line">    obj.fn &#x3D; this;</span><br><span class="line">    let result;</span><br><span class="line">    if(!arr)&#123;</span><br><span class="line">        result &#x3D; obj.fn()</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        result &#x3D; obj.fn(...arr)</span><br><span class="line">    &#125;</span><br><span class="line">    delete obj.fn;</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line">fn.apply_(obj,[&#39;我的&#39;,&#39;宠物&#39;,&#39;是&#39;])</span><br></pre></td></tr></table></figure>
<p>bind实现及代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind1 &#x3D; function()&#123;</span><br><span class="line">    &#x2F;&#x2F; 保存原函数</span><br><span class="line">    var self &#x3D; this;</span><br><span class="line">    &#x2F;&#x2F; 保存需要绑定的this上下文</span><br><span class="line">    context &#x3D; [].shift.call(arguments);</span><br><span class="line">    &#x2F;&#x2F; 剩余的参数转为数组</span><br><span class="line">    args &#x3D; [].slice.call(arguments);</span><br><span class="line">    &#x2F;&#x2F;返回一个函数</span><br><span class="line">    return  function()&#123;</span><br><span class="line">        self.apply(context,[].concat.call(args,[].slice.call(arguments)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lovefengruoqing/article/details/80186401">js中自己实现bind函数的方式</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/08/%E6%89%93%E9%80%9Acall%E3%80%81apply%E3%80%81bind/" data-id="ckmjwjiy4003m1ktj9omr3msh" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-剑指offer34-二叉树中和为某一值的路径" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/08/%E5%89%91%E6%8C%87offer34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/" class="article-date">
  <time datetime="2021-03-08T01:59:48.000Z" itemprop="datePublished">2021-03-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/">力扣刷题</a>►<a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/08/%E5%89%91%E6%8C%87offer34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/">剑指offer34--二叉树中和为某一值的路径</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/">剑指offer34–二叉树中和为某一值的路径</a></p>
<p>输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。</p>
<p>示例,给定sum和为32</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     &#x2F; \</span><br><span class="line">    4   8</span><br><span class="line">   &#x2F;   &#x2F; \</span><br><span class="line">  11  13  4</span><br><span class="line"> &#x2F;  \    &#x2F; \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>
<p>返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>代码及详细注释如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.left &#x3D; this.right &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @param &#123;number&#125; sum</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var pathSum &#x3D; function(root, sum) &#123;</span><br><span class="line">    &#x2F;&#x2F;放置结果</span><br><span class="line">    let result &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F;root--树，path--路径，curSum--当前节点和</span><br><span class="line">    const dfs &#x3D; (root,path,curSum)&#x3D;&gt;&#123;</span><br><span class="line">        &#x2F;&#x2F;递归结束条件</span><br><span class="line">        if(!root)&#123;</span><br><span class="line">            return [];</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F;路径添加元素</span><br><span class="line">        path.push(root.val);</span><br><span class="line">        &#x2F;&#x2F;计算当前和</span><br><span class="line">        curSum +&#x3D; root.val;</span><br><span class="line">        &#x2F;&#x2F;如果没有左子树和右子树（到了叶子节点）</span><br><span class="line">        if(!root.left &amp;&amp; !root.right)&#123;</span><br><span class="line">            if(curSum &#x3D;&#x3D;&#x3D; sum)&#123;</span><br><span class="line">                result.push(path.slice())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            &#x2F;&#x2F;递归左右子树</span><br><span class="line">            dfs(root.left,path,curSum);</span><br><span class="line">            dfs(root.right,path,curSum)</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F;返回上一步，回溯</span><br><span class="line">        path.pop();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root,[],0);</span><br><span class="line">    return result</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/08/%E5%89%91%E6%8C%87offer34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/" data-id="ckmjwjix2000q1ktj83ke91k4" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-力扣131-分割回文串" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/07/%E5%8A%9B%E6%89%A3131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/" class="article-date">
  <time datetime="2021-03-07T02:31:21.000Z" itemprop="datePublished">2021-03-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/">力扣刷题</a>►<a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/%E5%9B%9E%E6%BA%AF%E6%B3%95/">回溯法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/07/%E5%8A%9B%E6%89%A3131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/">力扣131-分割回文串</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-partitioning/">力扣131-分割回文串</a></p>
<p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>返回 s 所有可能的分割方案.</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aab&quot;</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>采用回溯法和动态规划，具体代码及注释如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string[][]&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var partition &#x3D; function(s) &#123;</span><br><span class="line">    &#x2F;&#x2F;dfs+动态规划</span><br><span class="line">    let len &#x3D; s.length;</span><br><span class="line">    let dp &#x3D; new Array(len);</span><br><span class="line">    for(let i &#x3D; 0;i &lt; len;i++)&#123;</span><br><span class="line">        dp[i] &#x3D; new Array(len)</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;设dp[i][j]为从i到j的字符串为回文串</span><br><span class="line">    for(let j &#x3D; 0;j &lt; len;j++)&#123;</span><br><span class="line">        for(let i &#x3D; 0;i &lt;&#x3D; j;i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;如果只有一个元素，本身就是回文串</span><br><span class="line">            if(i &#x3D;&#x3D; j)&#123;</span><br><span class="line">                dp[i][j] &#x3D; true</span><br><span class="line">            &#125;else if(j-1 &#x3D;&#x3D; i &amp;&amp; s[i] &#x3D;&#x3D; s[j])&#123;</span><br><span class="line">                &#x2F;&#x2F;要是i和j是相邻元素</span><br><span class="line">                dp[i][j] &#x3D; true;</span><br><span class="line">            &#125;else if(j-i &gt; 1 &amp;&amp; s[i] &#x3D;&#x3D; s[j] &amp;&amp; dp[i+1][j-1])&#123;</span><br><span class="line">                &#x2F;&#x2F;要是i和j不相邻，要保证最外层元素相同，里面是回文串</span><br><span class="line">                dp[i][j] &#x3D; true;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                dp[i][j] &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;回溯处理</span><br><span class="line">    &#x2F;&#x2F;保存最后结果</span><br><span class="line">    let res &#x3D; [];</span><br><span class="line">    const dfs &#x3D; (path,startIndex)&#x3D;&gt;&#123;</span><br><span class="line">        &#x2F;&#x2F;结束条件</span><br><span class="line">        if(startIndex &#x3D;&#x3D; len)&#123;</span><br><span class="line">            res.push(path.slice());</span><br><span class="line">            return</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F;限制重复性的组合，所以是基于上一次的选择</span><br><span class="line">        for(let i &#x3D; startIndex;i &lt; len;i++)&#123;    </span><br><span class="line">            if(dp[startIndex][i])&#123;</span><br><span class="line">                path.push(s.substring(startIndex,i+1));</span><br><span class="line">                &#x2F;&#x2F;限制重复性元素选择加进去</span><br><span class="line">                dfs(path,i+1);</span><br><span class="line">                path.pop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs([],0);</span><br><span class="line">    return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/07/%E5%8A%9B%E6%89%A3131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/" data-id="ckmjwjixg001p1ktjap2oe14z" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-剑指26-树的子结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/06/%E5%89%91%E6%8C%8726-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2021-03-06T07:10:48.000Z" itemprop="datePublished">2021-03-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/">力扣刷题</a>►<a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/06/%E5%89%91%E6%8C%8726-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/">剑指26-树的子结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指26-树的子结构</a></p>
<p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)B是A的子结构， 即 A中有出现和B相同的结构和节点值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.left &#x3D; this.right &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;TreeNode&#125; A</span><br><span class="line"> * @param &#123;TreeNode&#125; B</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var isSubStructure &#x3D; function(A, B) &#123;</span><br><span class="line">    &#x2F;&#x2F;约定空树不是任意一个树的子结构</span><br><span class="line">    if(!A || !B)&#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;;</span><br><span class="line">    return bfs(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B)</span><br><span class="line">&#125;;</span><br><span class="line">let bfs &#x3D; function(A,B)&#123;</span><br><span class="line">    &#x2F;&#x2F;如果B是空子树，A不为空，可以</span><br><span class="line">    if(!B)&#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;如果A是空子树，B不为空，不可以</span><br><span class="line">    if(!A)&#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;如果A、B对应的节点不相等不可以</span><br><span class="line">    if(A.val !&#x3D;&#x3D; B.val)&#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;递归判断左子树和右子树</span><br><span class="line">    return bfs(A.left,B.left) &amp;&amp; bfs(A.right,B.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/06/%E5%89%91%E6%8C%8726-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/" data-id="ckmjwjiwv000f1ktj91680ggz" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-力扣100-相同的树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/06/%E5%8A%9B%E6%89%A3100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/" class="article-date">
  <time datetime="2021-03-06T06:36:43.000Z" itemprop="datePublished">2021-03-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/">力扣刷题</a>►<a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/06/%E5%8A%9B%E6%89%A3100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/">力扣100-相同的树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/same-tree/">力扣100-相同的树</a></p>
<p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。<br>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val, left, right) &#123;</span><br><span class="line"> *     this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val)</span><br><span class="line"> *     this.left &#x3D; (left&#x3D;&#x3D;&#x3D;undefined ? null : left)</span><br><span class="line"> *     this.right &#x3D; (right&#x3D;&#x3D;&#x3D;undefined ? null : right)</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;TreeNode&#125; p</span><br><span class="line"> * @param &#123;TreeNode&#125; q</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var isSameTree &#x3D; function(p, q) &#123;</span><br><span class="line">    if(p &#x3D;&#x3D; null &amp;&amp; q &#x3D;&#x3D; null)&#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;;</span><br><span class="line">    if(p &#x3D;&#x3D; null || q &#x3D;&#x3D; null)&#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    if(p.val !&#x3D; q.val)&#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;;</span><br><span class="line">    return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/06/%E5%8A%9B%E6%89%A3100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/" data-id="ckmjwjix600131ktjes8sf7w4" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-从0开始手写promise" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/03/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99promise/" class="article-date">
  <time datetime="2021-03-03T09:38:49.000Z" itemprop="datePublished">2021-03-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>►<a class="article-category-link" href="/categories/JavaScript/ES6/">ES6</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/03/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99promise/">从0开始手写promise</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>我的妈呀，promise真是个神奇的东西，最近跟着侯策老师的书以及网上一堆的资料一步步理解手敲，现将笔记整理如下，从0开始逐步完善（只要记住最后的就好了，前面及中间一堆都是推理，帮助理解）。</p>
<p>Promise其实就是一个构造函数，，我们可以使用这个构造函数创建一个构造实例。函数中只有一个参数叫做executor，他是函数类型的参数，具有resolve，reject两个方法。</p>
<p>Promise构造函数返回一个Promise对象实例，这个返回的Promise对象具有一个then方法。在then方法中调用者可以定义两个参数，分别是onfulfilled和onrejected，都是函数类型的参数。其中onfulfilled通过参数可以获取Promise对象经过resolve处理后的值。</p>
<h3 id="Promise的初始"><a href="#Promise的初始" class="headerlink" title="Promise的初始"></a>Promise的初始</h3><p>在使用new关键字调用Promise 构造函数时，往往是异步操作结束时调用executor的参数resolve, 并将经过resolve处理后的值作为resolve的函数参数执行，这个值便可以后续then方法的第一个函数参数fulfilled中拿到;同理，在出现错误时，调用executor的参数reject,并将错误信息作为reject 的函数参数执行，这个错误信息可以在后续then方法的第二个函物数( onrejected) 中得到.</p>
<p>因此，实现Promise 时，应该有两个变量，分别存储经过resolve处理后的值，以及经计reject处理后的值(当然，因为Promise状态的唯一性，不可能同时出现经过resolve处理后的值和经过reject 处理后的值，因此也可以用一个变量来存储) ;同时还需要存在一个状态， 这个状态就是Promise实例的状态( pending、fulfilled、 rejected) ;最后要提供resolve方法及reject方法，这两个方法需要作为executor 的参数提供给开发者使用，代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Promise(executor)&#123;</span><br><span class="line">        this.status &#x3D; &#39;pending&#39;;</span><br><span class="line">        this.value &#x3D; null;</span><br><span class="line">        this.reason &#x3D; null;</span><br><span class="line">        const resolve &#x3D; (value) &#x3D;&gt;&#123;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">        &#125;;</span><br><span class="line">        const reject &#x3D; (reason)&#x3D;&gt;&#123;</span><br><span class="line">            this.reason &#x3D; reason;</span><br><span class="line">        &#125;;</span><br><span class="line">        executor(resolve,reject)</span><br><span class="line">    &#125;;</span><br><span class="line">Promise.prototype.then &#x3D; function(onfulfilled &#x3D; Function.prototype.onrejected &#x3D; Function.prototype)&#123;</span><br><span class="line">    onfulfilled(this.value)</span><br><span class="line">    onrejected(this.reason)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise实现状态完善"><a href="#Promise实现状态完善" class="headerlink" title="Promise实现状态完善"></a>Promise实现状态完善</h3><p>Promise实例的状态只能从pending变为fulfilled,或者从pending变为rejected，状态一旦变更无法发生变化。上述代码显然不能实现。完善如下，对状态进行判断。同时Promise.prototype.then的参数onfulfilled和onrejected进行判断，当实参不是函数类型时，需要赋予默认函数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function Promise(executor)&#123;</span><br><span class="line">        this.status &#x3D; &quot;pending&quot;;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">        this.reason &#x3D; reason;</span><br><span class="line">        const resolve &#x3D; (value)&#x3D;&gt;&#123;</span><br><span class="line">            if(this.status &#x3D;&#x3D; &quot;pending&quot;)&#123;</span><br><span class="line">                this.value &#x3D; value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        const reject &#x3D; (reason)&#x3D;&gt;&#123;</span><br><span class="line">            if(this.status &#x3D;&#x3D; &quot;pending&quot;)&#123;</span><br><span class="line">                this.reason &#x3D; reason</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        executor(resolve,reject)</span><br><span class="line">    &#125;;</span><br><span class="line">Promise.prototype.then &#x3D; function(onfulfilled,onrejected)&#123;</span><br><span class="line">    onfulfilled &#x3D; typeof onfulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onfulfilled:data &#x3D;&gt; data</span><br><span class="line">    onrejected &#x3D; typeof onrejected &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onrejected:error &#x3D;&gt;&#123;throw error&#125;</span><br><span class="line">    if(this.status &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;)&#123;</span><br><span class="line">        onfulfilled(this.value)</span><br><span class="line">    &#125;;</span><br><span class="line">    if(this.status &#x3D;&#x3D;&#x3D; &#39;rejected&#39;)&#123;</span><br><span class="line">        onrejected(this.reason)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise异步完善"><a href="#Promise异步完善" class="headerlink" title="Promise异步完善"></a>Promise异步完善</h3><p>Promise自然是为了解决异步问题的，下面示例，应该在两秒后输出信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let promise &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        resolve(&#39;data&#39;)</span><br><span class="line">    &#125;,2000)</span><br><span class="line">&#125;);</span><br><span class="line">promise.then((data)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上述代码在实例化一个 Promise的构造函数时，会在setTimeout逻辑中调用resolve,也就是说，2s后才会调用resolve方法，更改Promise实例状态。但是前面then方法中的onfulfilled 是同步执行的。我们可以先在状态( status )为pending时把开发者传进来的onfulfilled 方法存起来，再在resolve方法中执行即可。</p>
<p>同时，将resolve和reject方法放入队列中（暂时用setTimeout）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">将resolve和reject的执行放到任务队列中，暂时先用setTimeout实现</span><br><span class="line">function Promise1(executor)&#123;</span><br><span class="line">    this.status &#x3D; &#39;pending&#39;;</span><br><span class="line">    this.value &#x3D; null;</span><br><span class="line">    this.reason &#x3D; null;</span><br><span class="line">    this.onFulfilledFunc &#x3D; Function.prototype;</span><br><span class="line">    this.onrejectedFunc &#x3D; Function.prototype;</span><br><span class="line">    const resolve &#x3D; (value)&#x3D;&gt;&#123;</span><br><span class="line">        &#x2F;&#x2F; 判断传入元素是否为 Promise 值， 如果是， 则状态改变必须等待前一个状态改变后再进行改变</span><br><span class="line">        if(value instanceof Promise1)&#123;</span><br><span class="line">            return value.then(resolve,reject)</span><br><span class="line">        &#125;</span><br><span class="line">        setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">            if(this.status &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">                this.value &#x3D; value;</span><br><span class="line">                this.status &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">                this.onFulfilledFunc(this.value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    const reject &#x3D; (reason) &#x3D;&gt;&#123;</span><br><span class="line">        setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">            if(this.status &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">                this.reason &#x3D; reason;</span><br><span class="line">                this.status &#x3D; &#39;rejected&#39;;</span><br><span class="line">                this.onrejectedFunc(this.reason)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    executor(resolve,reject)</span><br><span class="line">&#125;;</span><br><span class="line">Promise1.prototype.then &#x3D; function(onfulfilled,onrejected)&#123;</span><br><span class="line">    onfulfilled &#x3D; typeof onfulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onfulfilled : data&#x3D;&gt;data</span><br><span class="line">    onrejected &#x3D; typeof onrejected &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onrejected : error&#x3D;&gt;&#123;throw error&#125;</span><br><span class="line">    if(this.status &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;)&#123;</span><br><span class="line">        onfulfilled(this.value)</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    if(this.status &#x3D;&#x3D;&#x3D; &#39;rejected&#39;)&#123;</span><br><span class="line">        rejected(this.reason)</span><br><span class="line">    &#125;;</span><br><span class="line">    if(this.status &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">        this.onFulfilledFunc&#x3D; onfulfilled;</span><br><span class="line">        this.onrejectedFunc &#x3D; onrejected;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let promise &#x3D; new Promise1((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">    resolve(&#39;data&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(data&#x3D;&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;);</span><br><span class="line">console.log(1)</span><br></pre></td></tr></table></figure>
<h3 id="Promise细节完善"><a href="#Promise细节完善" class="headerlink" title="Promise细节完善"></a>Promise细节完善</h3><p>同样，以实例为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">继续完善，在Promise实例状态可以添加多个then方法</span><br><span class="line">    let promise &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">        setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">            resolve(&#39;data&#39;)</span><br><span class="line">        &#125;,2000)</span><br><span class="line">    &#125;);</span><br><span class="line">    promise.then((data)&#x3D;&gt;&#123;</span><br><span class="line">        console.log(&#96;1:$&#123;data&#125;&#96;)</span><br><span class="line">    &#125;);</span><br><span class="line">    promise.then((data)&#x3D;&gt;&#123;</span><br><span class="line">        console.log(&#96;2:$&#123;data&#125;&#96;)</span><br><span class="line">    &#125;)</span><br><span class="line">    应该输出1:data,2:data</span><br></pre></td></tr></table></figure>
<p>为了实现这个功能，我们可以将then方法中的onFulfilled储存到一个数组中。代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将所有then中的方法中的onFulfilledFunc储存到一个数组中，在当前Promise中依次执行数组内的方法即可。</span><br><span class="line">    function Promise1(executor) &#123;</span><br><span class="line">        this.status &#x3D; &quot;pending&quot;;</span><br><span class="line">        this.reason &#x3D; null;</span><br><span class="line">        this.value &#x3D; null;</span><br><span class="line">        this.onFulfilledArray &#x3D; [];</span><br><span class="line">        this.onRejectedArray &#x3D; [];</span><br><span class="line">        const resolve &#x3D; (value) &#x3D;&gt; &#123;</span><br><span class="line">            if(value instanceof Promise1)&#123;</span><br><span class="line">                return value.then(resolve,reject)</span><br><span class="line">            &#125;</span><br><span class="line">            if (this.status &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    this.value &#x3D; value;</span><br><span class="line">                    this.status &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">                    this.onFulfilledArray.forEach((func) &#x3D;&gt; &#123;</span><br><span class="line">                        func(value)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        const reject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.status &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    this.status &#x3D; &#39;rejected&#39;;</span><br><span class="line">                    this.reason &#x3D; reason;</span><br><span class="line">                    this.onRejectedArray.forEach((func) &#x3D;&gt; &#123;</span><br><span class="line">                        func(reason)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        try&#123;</span><br><span class="line">            executor(resolve,reject)</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Promise1.prototype.then &#x3D; function(onfulfilled,onrejected)&#123;</span><br><span class="line">        onfulfilled &#x3D; typeof onfulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39;? onfulfilled:data&#x3D;&gt;data</span><br><span class="line">        onrejected &#x3D; typeof onrejected &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onrejected:error &#x3D;&gt;&#123;throw error&#125;</span><br><span class="line">        if(this.status &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;)&#123;</span><br><span class="line">            onfulfilled(this.value)</span><br><span class="line">        &#125;;</span><br><span class="line">        if(this.status &#x3D;&#x3D;&#x3D; &#39;rejected&#39;)&#123;</span><br><span class="line">            onrejected(this.reason)</span><br><span class="line">        &#125;;</span><br><span class="line">        if(this.status &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">            this.onFulfilledArray.push(onfulfilled);</span><br><span class="line">            this.onRejectedArray.push(onrejected)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    let promise &#x3D; new Promise1((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">        setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">            resolve(&#39;data&#39;)</span><br><span class="line">        &#125;,2000)</span><br><span class="line">    &#125;);</span><br><span class="line">    promise.then((data)&#x3D;&gt;&#123;</span><br><span class="line">        console.log(&#96;1:$&#123;data&#125;&#96;)</span><br><span class="line">    &#125;);</span><br><span class="line">    promise.then((data)&#x3D;&gt;&#123;</span><br><span class="line">        console.log(&#96;2:$&#123;data&#125;&#96;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>到此为止《初步实现了基本的Promsie，同时还有很多功能没有实现，比如Promise then的链式调用效果、Promise.all（）等方法。</p>
<h3 id="Promise-all实现"><a href="#Promise-all实现" class="headerlink" title="Promise.all实现"></a>Promise.all实现</h3><p>MDN上对于Promise all的解释是这样的: Promise all(iterable)方法返回一个Promise实例，此实例在iterable参数内的所有Promise实例都“完成”( resolved)或数中不包含 Promise实例时完成回调(resolve);如果参数中的Promise实例有一个失败(rejected)，则此实例回调失败( reject),失败原因是第一个Promise实例失败的原因。</p>
<p>下面仍然先通过一个例子来体会一下 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let promise1 &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        resolve(&#39;hello&#39;)</span><br><span class="line">    &#125;,2000)</span><br><span class="line">&#125;);</span><br><span class="line">let promise2 &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        resolve(&#39;hello,too&#39;)</span><br><span class="line">    &#125;,2000)</span><br><span class="line">&#125;);</span><br><span class="line">Promise.all([promise1,promise2]).then((data)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>执行上述代码，打印出([‘hello’,’hello too’])<br>Promise.all代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Promise1.all &#x3D; function (promiseArr) &#123;</span><br><span class="line">    &#x2F;&#x2F;对promiseArr类型进行判断，如果不是数组则抛错</span><br><span class="line">    if (!Array.isArray(promiseArr)) &#123;</span><br><span class="line">        throw new TypeError(&#39;出错了&#39;)</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    return new Promise1((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            let len &#x3D; promiseArr.length;</span><br><span class="line">            let resultArr &#x3D; [];</span><br><span class="line">            for(let i &#x3D; 0;i &lt; len;i++)&#123;</span><br><span class="line">                promiseArr[i].then((data)&#x3D;&gt;&#123;</span><br><span class="line">                    resultArr.push(data);</span><br><span class="line">                    if(resultArr.length &#x3D;&#x3D;&#x3D; len)&#123;</span><br><span class="line">                        resolve(resultArr)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-race-实现"><a href="#Promise-race-实现" class="headerlink" title="Promise.race()实现"></a>Promise.race()实现</h3><p>Promse.race就是赛跑的意思，说白了，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#39;success&#39;)</span><br><span class="line">  &#125;,1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    reject(&#39;failed&#39;)</span><br><span class="line">  &#125;, 500)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Promise.race([p1, p2]).then((result) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(result)</span><br><span class="line">&#125;).catch((error) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(error)  &#x2F;&#x2F; 打开的是 &#39;failed&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>实现代码与Promise.all类似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Promise1.race &#x3D; function(promiseArr)&#123;</span><br><span class="line">    if(!Array.isArray(promiseArr))&#123;</span><br><span class="line">        throw new TypeError(&#39;请输入数组&#39;)</span><br><span class="line">    &#125;;</span><br><span class="line">    return new Promise1((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            let len &#x3D; promiseArr.length;</span><br><span class="line">            for(let i &#x3D; 0;i &lt; len;i++)&#123;</span><br><span class="line">                promiseArr[i].then(resolve,reject)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/03/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99promise/" data-id="ckmjwjiws000b1ktj54ba5wmu" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-亲爱的排序算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/02/%E4%BA%B2%E7%88%B1%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2021-03-02T02:24:25.000Z" itemprop="datePublished">2021-03-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>►<a class="article-category-link" href="/categories/JavaScript/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/02/%E4%BA%B2%E7%88%B1%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">亲爱的排序算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ol>
<li>如果遇到相等的值不进行交换，那这种排序方式是稳定的排序方式</li>
<li>比较相邻的两个元素，如果前一个比后一个大，则交换位置。</li>
<li>比较完第一轮的时候，最后一个元素是最大的元素。</li>
<li>这时候最后一个元素是最大的，所以最后一个元素就不需要参与比较大小。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;冒泡排序</span><br><span class="line">function maoPao(arr)&#123;</span><br><span class="line">    let len &#x3D; arr.length;</span><br><span class="line">    &#x2F;&#x2F;比较相邻的元素，第一轮比到最后的时候，最后一个自然是最大&#x2F;最小，就不用参与比较</span><br><span class="line">    for(let i &#x3D; 0;i &lt; len-1;i++)&#123;</span><br><span class="line">        for(let j &#x3D; 0;j &lt; len-1-i;j++)&#123;</span><br><span class="line">            if(arr[j] &gt; arr[j+1])&#123;</span><br><span class="line">                [arr[j],arr[j+1]] &#x3D; [arr[j+1],arr[j]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return arr</span><br><span class="line">&#125;;</span><br><span class="line">let arr1 &#x3D; [2,5,1,7,8,6];</span><br><span class="line">console.log(maoPao(arr1))</span><br></pre></td></tr></table></figure>
冒泡排序时间复杂度，最好是O(n)，最差是O(n^2),稳定性较好，稳定</li>
</ol>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序由于排序效率在同为O(N*logN)的几种排序方法中效率较高，因此经常被采用，其思想是分治。快速排序是一种既不浪费空间又可以快一点的排序算法。</p>
<p>步骤：</p>
<ol>
<li>先从数列中取出一个数作为“基准”。</li>
<li>分区过程：将比这个“基准”大的数全放到“基准”的右边，小于或等于“基准”的数全放到“基准”的左边。</li>
<li>再对左右区间重复第二步，直到各区间只有一个数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;快速排序</span><br><span class="line">&#x2F;&#x2F;借助分冶思想，以一个数位基准，大于这个数的放一边，小于这个数的放一边，直到区间值为1为止</span><br><span class="line">function quickSort(arr)&#123;</span><br><span class="line">    &#x2F;&#x2F;递归条件</span><br><span class="line">    if(arr.length &lt;&#x3D; 1)&#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;;</span><br><span class="line">    let left &#x3D; [];</span><br><span class="line">    let right &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F;基准值</span><br><span class="line">    let start &#x3D; arr.shift();</span><br><span class="line">    for(let value of arr)&#123;</span><br><span class="line">        if(value &gt; start)&#123;</span><br><span class="line">            right.push(value)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            left.push(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;基准左边的值</span><br><span class="line">    let l &#x3D; quickSort(left);</span><br><span class="line">    &#x2F;&#x2F;基准右边的值</span><br><span class="line">    let r &#x3D; quickSort(right);</span><br><span class="line">    &#x2F;&#x2F;不要忘了基准自己</span><br><span class="line">    return l.concat(start,r)</span><br><span class="line">&#125;</span><br><span class="line">let arr1 &#x3D; [2,5,1,7,8,6];</span><br><span class="line">console.log(quickSort(arr1))</span><br></pre></td></tr></table></figure>
<p>快速排序时间复杂度最差是O(n^2),最好是O(nlogn)，不稳定</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。将第一个元素当成有序序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;插入排序</span><br><span class="line">function insertSort(arr) &#123;</span><br><span class="line">    let len &#x3D; arr.length;</span><br><span class="line">    &#x2F;&#x2F;以第一个为有序，从i&#x3D;1开始</span><br><span class="line">    for (let i &#x3D; 1; i &lt; len; i++) &#123;</span><br><span class="line">        let j &#x3D; i - 1;</span><br><span class="line">        if (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">            let temp &#x3D; arr[i];</span><br><span class="line">            while (j &gt;&#x3D; 0 &amp;&amp; temp &lt; arr[j]) &#123;</span><br><span class="line">                arr[j + 1] &#x3D; arr[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;;</span><br><span class="line">            arr[j + 1] &#x3D; temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line">let arr1 &#x3D; [2, 5, 1, 7, 8, 6];</span><br><span class="line">console.log(insertSort(arr1))</span><br></pre></td></tr></table></figure>
<p>插入排序时间复杂度最差是O(n^2),最好是O(n)，稳定</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是插入排序的一种又称“缩小增量排序”，是直接插入排序算法的一种更高效的改进版本。</p>
<p>算法先将要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。本质还是插入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;希尔排序</span><br><span class="line">function shellSort(arr)&#123;</span><br><span class="line">    let len &#x3D; arr.length;</span><br><span class="line">    for(let gap &#x3D; Math.floor(len&#x2F;2);gap &gt;&#x3D; 1;gap &#x3D; Math.floor(gap&#x2F;2))&#123;</span><br><span class="line">        &#x2F;&#x2F; 内层循环与插入排序的写法基本一致，只是每次移动的步长变为 gap</span><br><span class="line">        for(let i &#x3D; gap;i &lt; len;i++)&#123;</span><br><span class="line">            let j &#x3D; i-gap;</span><br><span class="line">            if(arr[i] &lt; arr[j])&#123;</span><br><span class="line">                let temp &#x3D; arr[i]</span><br><span class="line">                while(j&gt;&#x3D;0 &amp;&amp; arr[j] &gt; temp)&#123;</span><br><span class="line">                    arr[j+gap] &#x3D; arr[j];</span><br><span class="line">                    j -&#x3D; gap;</span><br><span class="line">                &#125;;</span><br><span class="line">                arr[j+gap] &#x3D; temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line">let arr1 &#x3D; [2, 5, 1, 7, 8, 6];</span><br><span class="line">console.log(shellSort(arr1))</span><br></pre></td></tr></table></figure>
<p>插入排序时间复杂度最差是O(n^2),最好是O(n)，不稳定</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>把一个有n个记录的无序文件看成是由n个长度为1的有序子文件组成的文件，然后进行两两归并</p>
<p>本质是分冶，先分再合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function mergeSort(arr)&#123;</span><br><span class="line">        let len &#x3D; arr.length;</span><br><span class="line">        if(arr.length &lt;&#x3D; 1)&#123;</span><br><span class="line">            return arr</span><br><span class="line">        &#125;</span><br><span class="line">        let mid &#x3D; Math.floor(len&#x2F;2);</span><br><span class="line">        let left &#x3D; arr.slice(0,mid);</span><br><span class="line">        let right &#x3D; arr.slice(mid,len);</span><br><span class="line">        let l &#x3D;mergeSort(left);</span><br><span class="line">        let r &#x3D; mergeSort(right);</span><br><span class="line">        return merge(l,r)</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    function merge(left,right)&#123;</span><br><span class="line">        let result &#x3D; [];</span><br><span class="line">        while(left.length &amp;&amp; right.length)&#123;</span><br><span class="line">            if(left[0] &lt;&#x3D; right[0])&#123;</span><br><span class="line">                result.push(left.shift())</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                result.push(right.shift())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        while(left.length)&#123;</span><br><span class="line">            result.push(left.shift())</span><br><span class="line">        &#125;;</span><br><span class="line">        while(right.length)&#123;</span><br><span class="line">            result.push(right.shift())</span><br><span class="line">        &#125;;</span><br><span class="line">        return result</span><br><span class="line">    &#125;;</span><br><span class="line">    let arr1 &#x3D; [2, 5, 1, 7, 8, 6];</span><br><span class="line">    console.log(mergeSort(arr1))</span><br></pre></td></tr></table></figure>
<p>快速排序时间复杂度最差是O(nlogn),最好是O(nlogn)，稳定</p>
<h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><p>在第i次选择操作中，通过n-i次键值间比较，从n-i+1个记录中选出键值最小的记录，并和第i（1小于等于1小于等于n-1）个记录交换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;直接选择排序</span><br><span class="line">function selectSort(arr1)&#123;</span><br><span class="line">    let len &#x3D; arr1.length;</span><br><span class="line">    for(let i &#x3D; 0;i &lt; len;i++)&#123;</span><br><span class="line">        let min &#x3D; Math.max(...arr1.slice(i));</span><br><span class="line">        let index &#x3D; arr1.indexOf(min);</span><br><span class="line">        [arr1[i],arr1[index]] &#x3D; [arr1[index],arr1[i]]</span><br><span class="line">    &#125;;</span><br><span class="line">    return arr1</span><br><span class="line">&#125;</span><br><span class="line">let arr1 &#x3D; [2, 5, 1, 7, 8, 6];</span><br><span class="line">console.log(selectSort(arr1))</span><br></pre></td></tr></table></figure>
<p>插入排序时间复杂度最差是O(n^2),最好是O(n^2),不稳定</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/02/%E4%BA%B2%E7%88%B1%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-id="ckmjwjiwm00081ktj08xn656u" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-原型对象和继承" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/01/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%BB%A7%E6%89%BF/" class="article-date">
  <time datetime="2021-03-01T12:36:48.000Z" itemprop="datePublished">2021-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>►<a class="article-category-link" href="/categories/JavaScript/%E5%AF%B9%E8%B1%A1/">对象</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/01/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%BB%A7%E6%89%BF/">原型对象和继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>结合自己的理解以及相关资料，将原型对象和继承的知识点记录如下：</p>
<h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><ol>
<li>原型对象、构造函数、实例之间的关系</li>
</ol>
<p>在 js 中我们是使用构造函数来新建一个对象的， 每一个构造函数的内部都有一个 prototype属性值， 它指向函数的原型对象，所以这个属性值是一个对象， 这个对象包含了可以由该构造函数的所有实例共享的属性和方法。因此在使用prototype属性之后，就可以将实例共享的属性和函数抽离出构造函数，将他们添加在prototype属性中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age</span><br><span class="line">    &#125;</span><br><span class="line">Person.prototype.weight &#x3D; function()&#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>实例共享的weight()函数就被添加在了Person.prototype属性上。</p>
<p>构造函数的prototype属性会指向它的原型对象，而通过构造函数可以生成具体的实例。三者之间的关系如何？</p>
<p>每一个构造函数的内部都有一个 prototype属性，在默认的情况下，所有的原型对象都会增加一个constructor属性，指向prototype所在的函数，即构造函数。</p>
<p>当我们通过new调用构造函数创建一个实例时，实例会具有一个__proto__属性，指向构造函数的原型对象，因此，__proto__属性可以看成是一个连接实例与构造函数的原型对象的桥梁。</p>
<p>下面这段代码为构造函数的原型对象添加了3个属性，同时生成两个实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;;</span><br><span class="line">Person.prototype.name &#x3D; &quot;xiaobai&quot;;</span><br><span class="line">Person.prototype.age &#x3D; 18;</span><br><span class="line">Person.prototype.sayname &#x3D; function()&#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;;</span><br><span class="line">var person1 &#x3D; new Person();</span><br><span class="line">var person2 &#x3D; new Person();</span><br></pre></td></tr></table></figure>
<p>以构造函数Person为例来看，构造函数原型对象和实例之间的关系<br><img src="/2021/03/01/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%BB%A7%E6%89%BF/pic1.png"><br>2. 原型链<br>对象的每个实例都有__proto__属性，指向构造函数的原型对象，而原型对象上同样也是存在着一个__proto__属性指向上一级构造函数的原型对象，就这样层层往上，直到最上层某个原型对象为 Null.</p>
<p>在JS中几乎所有的对象都有__proto__属性，由__proto__属性连接而成的链路构成了JS的原型链，原型链的顶端是Object.prototype，他的__proto__属性为Null</p>
<p>原型链的特点:<br>1）由于原型链的存在，属性查找的过程不再是查找自身的原型对象，而是会沿着整个原型链一直向上，直到追溯到Object.prototype，再找不到就返回undefined</p>
<p>由于上述特点，在生成自定义对象的实例时，也可以调用某些未在自定义构造函数上的函数，如toString()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;;</span><br><span class="line">var p &#x3D; new Person();</span><br><span class="line">p.toString()</span><br><span class="line">&#x2F;&#x2F;[object object],实际调用的是Object.prototype.toString()函数</span><br></pre></td></tr></table></figure>
<p>2)由于属性的查找会经历整个链路，因此查找的链路越长，对性能影响越大。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>ES5继承方式有多种，包括原型链继承、构造继承、复制继承、组合继承、寄生组合继承等,各有优缺点。下面实现几种继承（ES5）</p>
<ol>
<li>原型链继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;定义一个父类Animal</span><br><span class="line">function Animal(name) &#123;</span><br><span class="line">    &#x2F;&#x2F;属性</span><br><span class="line">    this.type &#x3D; &#39;Animal&#39;;</span><br><span class="line">    this.name &#x3D; name || &#39;动物&#39;;</span><br><span class="line">    &#x2F;&#x2F;实例函数</span><br><span class="line">    this.sleep &#x3D; function () &#123;</span><br><span class="line">        console.log(this.name + &#39;正在睡觉&#39;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;原型函数</span><br><span class="line">Animal.prototype.eat &#x3D; function (food) &#123;</span><br><span class="line">    console.log(this.name + &#39;正在吃&#39; + food)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#x2F;&#x2F;1 原型链继承</span><br><span class="line">&#x2F;&#x2F; &#x2F;&#x2F;主要思想：重写子类的prototype属性，将其指向父类的实例</span><br><span class="line">&#x2F;&#x2F; &#x2F;&#x2F;定义一个子类Cat,用于继承父类Animal,子类的实现如下；</span><br><span class="line">function Cat(name)&#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;原型继承</span><br><span class="line">Cat.prototype &#x3D; new Animal();</span><br><span class="line">&#x2F;&#x2F;关键！将Cat的构造函数指向自身</span><br><span class="line">Cat.prototype.constructor &#x3D; Cat;</span><br><span class="line">var cat &#x3D; new Cat(&#39;小猫咪&#39;);</span><br><span class="line">console.log(cat.name);</span><br><span class="line">console.log(cat.type);</span><br><span class="line">console.log(cat.sleep());</span><br><span class="line">console.log(cat.eat(&#39;鱼干&#39;))</span><br><span class="line">console.log(cat instanceof Animal)</span><br></pre></td></tr></table></figure></li>
<li>构造继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构造继承</span><br><span class="line">function Cat(name)&#123;</span><br><span class="line">    &#x2F;&#x2F;关键，通过call()函数实现Animal的实例的属性和函数的继承</span><br><span class="line">    Animal.call(this);</span><br><span class="line">    this.name &#x3D; name || &#39;tony&#39;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">var p1 &#x3D; new Cat(&#39;猫猫&#39;);</span><br><span class="line">console.log(p1.name);</span><br><span class="line">console.log(p1.type);</span><br><span class="line">console.log(p1.sleep());</span><br><span class="line">&#x2F;&#x2F;Uncaught TypeError: p1.eat is not a function</span><br><span class="line">console.log(p1.eat())</span><br><span class="line">&#x2F;&#x2F;可以发现，子类可以正常调用父类的实例函数，而无法调用父类原型对象上的函数</span><br></pre></td></tr></table></figure></li>
<li>组合继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">组合继承</span><br><span class="line">组合继承的主要思想是组合了构造继承和原型继承两种方法，一方面在子类的构造函数中通过call()函数</span><br><span class="line">调用父类的构造函数，将父类的实例的属性和函数绑定到子类的this中；</span><br><span class="line">另一方面通过改变子类的prototype属性，继承父类的原型对象上的属性和函数</span><br><span class="line">function Cat(name) &#123;</span><br><span class="line">    &#x2F;&#x2F;通过构造函数继承实例的属性和函数</span><br><span class="line">    Animal.call(this);</span><br><span class="line">    this.name &#x3D; name || &#39;hania&#39;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;通过原型继承原型对象上的属性和函数</span><br><span class="line">Cat.prototype &#x3D; new Animal();</span><br><span class="line">Cat.prototype.constructor &#x3D; Cat;</span><br><span class="line">var cat &#x3D; new Cat(&#39;shishi&#39;);</span><br><span class="line">console.log(cat.name);</span><br><span class="line">console.log(cat.sleep());</span><br><span class="line">console.log(cat.eat(&#39;好吃的&#39;))      </span><br></pre></td></tr></table></figure></li>
<li>寄生式组合继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;组合继承的缺点是父类的实例属性回绑定两次</span><br><span class="line">&#x2F;&#x2F;针对上述缺点，有了寄生组合继承</span><br><span class="line">&#x2F;&#x2F;在进行子类的prototype属性的设置时，可以去掉父类实例的属性和函数</span><br><span class="line">&#x2F;&#x2F;子类</span><br><span class="line">function Cat(name) &#123;</span><br><span class="line">    Animal.call(this);</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;设置任意的函数Super</span><br><span class="line">var Super &#x3D; function () &#123; &#125;;</span><br><span class="line">&#x2F;&#x2F;关键 Super()函数的原型指向父类Animal的原型，去掉父类的实例属性</span><br><span class="line">Super.prototype &#x3D; Animal.prototype;</span><br><span class="line">Cat.prototype &#x3D; new Super();</span><br><span class="line">Cat.prototype.constructor &#x3D; Cat;</span><br><span class="line">var cat &#x3D; new Cat(&#39;shishi&#39;);</span><br><span class="line">console.log(cat.name);</span><br><span class="line">console.log(cat.sleep());</span><br><span class="line">console.log(cat.eat(&#39;好吃的ya&#39;))</span><br></pre></td></tr></table></figure>
<h2 id="ES6中对象及继承"><a href="#ES6中对象及继承" class="headerlink" title="ES6中对象及继承"></a>ES6中对象及继承</h2></li>
<li>ES6中引入了Class(类)的概念，通过class关键字定义类的名字，然后在constructor构造函数中定义实例属性，原型属性在class内部直接声明并赋值，原型函数的声明与构造函数处于同一层级，并且省略function关键字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Cat&#123;</span><br><span class="line">    &#x2F;&#x2F;原型属性</span><br><span class="line">    publicCount &#x3D; 1;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        &#x2F;&#x2F;实例属性</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;原型函数</span><br><span class="line">    getName()&#123;</span><br><span class="line">        return this.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p &#x3D; new Cat(&#39;shishi&#39;,12)</span><br><span class="line">console.log(p.getName())</span><br></pre></td></tr></table></figure></li>
<li>class继承<br>ES6中新增了extends关键字，可以快速实现类的继承<br>在子类的constructor构造函数中，需要首先调用super()函数执行父类的构造函数，再执行子类的函数修饰this.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ES6class继承</span><br><span class="line">class Dad&#123;</span><br><span class="line">    constructor(type)&#123;</span><br><span class="line">        this.type &#x3D; type</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Son extends Dad&#123;</span><br><span class="line">    constructor(type,name)&#123;</span><br><span class="line">        super(type);</span><br><span class="line">        this.name &#x3D; name</span><br><span class="line">    &#125;;</span><br><span class="line">    getName()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let son &#x3D; new Son(&#39;mimi&#39;,&#39;Tom&#39;);</span><br><span class="line">console.log(son.type)</span><br></pre></td></tr></table></figure>
//关于ES6的知识学习阮一峰老师的书</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/01/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%BB%A7%E6%89%BF/" data-id="ckmjwjiy3003j1ktjhl9w59b9" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/4/">下一页&amp;raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/03/21/%E5%8A%9B%E6%89%A373-%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/">力扣73--矩阵置零</a>
          </li>
        
          <li>
            <a href="/2021/03/19/%E5%8A%9B%E6%89%A3309-%E6%9C%80%E4%BD%B3%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F/">力扣309--最佳买卖股票时机含冷冻期</a>
          </li>
        
          <li>
            <a href="/2021/03/19/%E5%8A%9B%E6%89%A3714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9/">力扣714--买卖股票的最佳时机含手续费</a>
          </li>
        
          <li>
            <a href="/2021/03/19/%E5%8A%9B%E6%89%A3-1603%E8%AE%BE%E8%AE%A1%E5%81%9C%E8%BD%A6%E7%B3%BB%E7%BB%9F/">力扣--1603设计停车系统</a>
          </li>
        
          <li>
            <a href="/2021/03/17/%E5%8A%9B%E6%89%A334-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/">力扣34-在排序数组中查找元素的第一个和最后一个位置</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2021 jianjian&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;2040787513@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
    <a href="/categories" class="mobile-nav-link">分类</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>