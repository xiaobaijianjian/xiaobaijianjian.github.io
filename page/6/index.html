<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Welcome To My Learning Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Welcome To My Learning Blog">
<meta property="og:url" content="http://example.com/page/6/index.html">
<meta property="og:site_name" content="Welcome To My Learning Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="jianjian">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  
<link rel="stylesheet" href="/css/style.css">

  

<meta name="generator" content="Hexo 5.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
          <a class="main-nav-link" href="/categories">分类</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Welcome To My Learning Blog</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-力扣131-分割回文串" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/07/%E5%8A%9B%E6%89%A3131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/" class="article-date">
  <time datetime="2021-03-07T02:31:21.000Z" itemprop="datePublished">2021-03-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/">力扣刷题</a>►<a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/%E5%9B%9E%E6%BA%AF%E6%B3%95/">回溯法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/07/%E5%8A%9B%E6%89%A3131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/">力扣131-分割回文串</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-partitioning/">力扣131-分割回文串</a></p>
<p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>返回 s 所有可能的分割方案.</p>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;aab&quot;</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>采用回溯法和动态规划，具体代码及注释如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;string&#125; s</span><br><span class="line"> * @return &#123;string[][]&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var partition &#x3D; function(s) &#123;</span><br><span class="line">    &#x2F;&#x2F;dfs+动态规划</span><br><span class="line">    let len &#x3D; s.length;</span><br><span class="line">    let dp &#x3D; new Array(len);</span><br><span class="line">    for(let i &#x3D; 0;i &lt; len;i++)&#123;</span><br><span class="line">        dp[i] &#x3D; new Array(len)</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;设dp[i][j]为从i到j的字符串为回文串</span><br><span class="line">    for(let j &#x3D; 0;j &lt; len;j++)&#123;</span><br><span class="line">        for(let i &#x3D; 0;i &lt;&#x3D; j;i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;如果只有一个元素，本身就是回文串</span><br><span class="line">            if(i &#x3D;&#x3D; j)&#123;</span><br><span class="line">                dp[i][j] &#x3D; true</span><br><span class="line">            &#125;else if(j-1 &#x3D;&#x3D; i &amp;&amp; s[i] &#x3D;&#x3D; s[j])&#123;</span><br><span class="line">                &#x2F;&#x2F;要是i和j是相邻元素</span><br><span class="line">                dp[i][j] &#x3D; true;</span><br><span class="line">            &#125;else if(j-i &gt; 1 &amp;&amp; s[i] &#x3D;&#x3D; s[j] &amp;&amp; dp[i+1][j-1])&#123;</span><br><span class="line">                &#x2F;&#x2F;要是i和j不相邻，要保证最外层元素相同，里面是回文串</span><br><span class="line">                dp[i][j] &#x3D; true;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                dp[i][j] &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;回溯处理</span><br><span class="line">    &#x2F;&#x2F;保存最后结果</span><br><span class="line">    let res &#x3D; [];</span><br><span class="line">    const dfs &#x3D; (path,startIndex)&#x3D;&gt;&#123;</span><br><span class="line">        &#x2F;&#x2F;结束条件</span><br><span class="line">        if(startIndex &#x3D;&#x3D; len)&#123;</span><br><span class="line">            res.push(path.slice());</span><br><span class="line">            return</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F;限制重复性的组合，所以是基于上一次的选择</span><br><span class="line">        for(let i &#x3D; startIndex;i &lt; len;i++)&#123;    </span><br><span class="line">            if(dp[startIndex][i])&#123;</span><br><span class="line">                path.push(s.substring(startIndex,i+1));</span><br><span class="line">                &#x2F;&#x2F;限制重复性元素选择加进去</span><br><span class="line">                dfs(path,i+1);</span><br><span class="line">                path.pop()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    dfs([],0);</span><br><span class="line">    return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/07/%E5%8A%9B%E6%89%A3131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/" data-id="cknvroz85001zvotjcijwdf4p" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-剑指26-树的子结构" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/06/%E5%89%91%E6%8C%8726-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/" class="article-date">
  <time datetime="2021-03-06T07:10:48.000Z" itemprop="datePublished">2021-03-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/">力扣刷题</a>►<a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/06/%E5%89%91%E6%8C%8726-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/">剑指26-树的子结构</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指26-树的子结构</a></p>
<p>输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)B是A的子结构， 即 A中有出现和B相同的结构和节点值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.left &#x3D; this.right &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;TreeNode&#125; A</span><br><span class="line"> * @param &#123;TreeNode&#125; B</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var isSubStructure &#x3D; function(A, B) &#123;</span><br><span class="line">    &#x2F;&#x2F;约定空树不是任意一个树的子结构</span><br><span class="line">    if(!A || !B)&#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;;</span><br><span class="line">    return bfs(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B)</span><br><span class="line">&#125;;</span><br><span class="line">let bfs &#x3D; function(A,B)&#123;</span><br><span class="line">    &#x2F;&#x2F;如果B是空子树，A不为空，可以</span><br><span class="line">    if(!B)&#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;如果A是空子树，B不为空，不可以</span><br><span class="line">    if(!A)&#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;如果A、B对应的节点不相等不可以</span><br><span class="line">    if(A.val !&#x3D;&#x3D; B.val)&#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;递归判断左子树和右子树</span><br><span class="line">    return bfs(A.left,B.left) &amp;&amp; bfs(A.right,B.right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/06/%E5%89%91%E6%8C%8726-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/" data-id="cknvroz7n000lvotj9djk4jgp" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-力扣100-相同的树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/06/%E5%8A%9B%E6%89%A3100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/" class="article-date">
  <time datetime="2021-03-06T06:36:43.000Z" itemprop="datePublished">2021-03-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/">力扣刷题</a>►<a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/06/%E5%8A%9B%E6%89%A3100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/">力扣100-相同的树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/same-tree/">力扣100-相同的树</a></p>
<p>给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。<br>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val, left, right) &#123;</span><br><span class="line"> *     this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val)</span><br><span class="line"> *     this.left &#x3D; (left&#x3D;&#x3D;&#x3D;undefined ? null : left)</span><br><span class="line"> *     this.right &#x3D; (right&#x3D;&#x3D;&#x3D;undefined ? null : right)</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;TreeNode&#125; p</span><br><span class="line"> * @param &#123;TreeNode&#125; q</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var isSameTree &#x3D; function(p, q) &#123;</span><br><span class="line">    if(p &#x3D;&#x3D; null &amp;&amp; q &#x3D;&#x3D; null)&#123;</span><br><span class="line">        return true</span><br><span class="line">    &#125;;</span><br><span class="line">    if(p &#x3D;&#x3D; null || q &#x3D;&#x3D; null)&#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">    if(p.val !&#x3D; q.val)&#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;;</span><br><span class="line">    return isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right,q.right)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/06/%E5%8A%9B%E6%89%A3100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/" data-id="cknvroz80001ivotj4dtz1uyy" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-从0开始手写promise" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/03/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99promise/" class="article-date">
  <time datetime="2021-03-03T09:38:49.000Z" itemprop="datePublished">2021-03-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>►<a class="article-category-link" href="/categories/JavaScript/ES6/">ES6</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/03/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99promise/">从0开始手写promise</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>我的妈呀，promise真是个神奇的东西，最近跟着侯策老师的书以及网上一堆的资料一步步理解手敲，现将笔记整理如下，从0开始逐步完善（只要记住最后的就好了，前面及中间一堆都是推理，帮助理解）。</p>
<p>Promise其实就是一个构造函数，，我们可以使用这个构造函数创建一个构造实例。函数中只有一个参数叫做executor，他是函数类型的参数，具有resolve，reject两个方法。</p>
<p>Promise构造函数返回一个Promise对象实例，这个返回的Promise对象具有一个then方法。在then方法中调用者可以定义两个参数，分别是onfulfilled和onrejected，都是函数类型的参数。其中onfulfilled通过参数可以获取Promise对象经过resolve处理后的值。</p>
<h3 id="Promise的初始"><a href="#Promise的初始" class="headerlink" title="Promise的初始"></a>Promise的初始</h3><p>在使用new关键字调用Promise 构造函数时，往往是异步操作结束时调用executor的参数resolve, 并将经过resolve处理后的值作为resolve的函数参数执行，这个值便可以后续then方法的第一个函数参数fulfilled中拿到;同理，在出现错误时，调用executor的参数reject,并将错误信息作为reject 的函数参数执行，这个错误信息可以在后续then方法的第二个函物数( onrejected) 中得到.</p>
<p>因此，实现Promise 时，应该有两个变量，分别存储经过resolve处理后的值，以及经计reject处理后的值(当然，因为Promise状态的唯一性，不可能同时出现经过resolve处理后的值和经过reject 处理后的值，因此也可以用一个变量来存储) ;同时还需要存在一个状态， 这个状态就是Promise实例的状态( pending、fulfilled、 rejected) ;最后要提供resolve方法及reject方法，这两个方法需要作为executor 的参数提供给开发者使用，代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function Promise(executor)&#123;</span><br><span class="line">        this.status &#x3D; &#39;pending&#39;;</span><br><span class="line">        this.value &#x3D; null;</span><br><span class="line">        this.reason &#x3D; null;</span><br><span class="line">        const resolve &#x3D; (value) &#x3D;&gt;&#123;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">        &#125;;</span><br><span class="line">        const reject &#x3D; (reason)&#x3D;&gt;&#123;</span><br><span class="line">            this.reason &#x3D; reason;</span><br><span class="line">        &#125;;</span><br><span class="line">        executor(resolve,reject)</span><br><span class="line">    &#125;;</span><br><span class="line">Promise.prototype.then &#x3D; function(onfulfilled &#x3D; Function.prototype.onrejected &#x3D; Function.prototype)&#123;</span><br><span class="line">    onfulfilled(this.value)</span><br><span class="line">    onrejected(this.reason)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise实现状态完善"><a href="#Promise实现状态完善" class="headerlink" title="Promise实现状态完善"></a>Promise实现状态完善</h3><p>Promise实例的状态只能从pending变为fulfilled,或者从pending变为rejected，状态一旦变更无法发生变化。上述代码显然不能实现。完善如下，对状态进行判断。同时Promise.prototype.then的参数onfulfilled和onrejected进行判断，当实参不是函数类型时，需要赋予默认函数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function Promise(executor)&#123;</span><br><span class="line">        this.status &#x3D; &quot;pending&quot;;</span><br><span class="line">        this.value &#x3D; value;</span><br><span class="line">        this.reason &#x3D; reason;</span><br><span class="line">        const resolve &#x3D; (value)&#x3D;&gt;&#123;</span><br><span class="line">            if(this.status &#x3D;&#x3D; &quot;pending&quot;)&#123;</span><br><span class="line">                this.value &#x3D; value</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        const reject &#x3D; (reason)&#x3D;&gt;&#123;</span><br><span class="line">            if(this.status &#x3D;&#x3D; &quot;pending&quot;)&#123;</span><br><span class="line">                this.reason &#x3D; reason</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        executor(resolve,reject)</span><br><span class="line">    &#125;;</span><br><span class="line">Promise.prototype.then &#x3D; function(onfulfilled,onrejected)&#123;</span><br><span class="line">    onfulfilled &#x3D; typeof onfulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onfulfilled:data &#x3D;&gt; data</span><br><span class="line">    onrejected &#x3D; typeof onrejected &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onrejected:error &#x3D;&gt;&#123;throw error&#125;</span><br><span class="line">    if(this.status &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;)&#123;</span><br><span class="line">        onfulfilled(this.value)</span><br><span class="line">    &#125;;</span><br><span class="line">    if(this.status &#x3D;&#x3D;&#x3D; &#39;rejected&#39;)&#123;</span><br><span class="line">        onrejected(this.reason)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise异步完善"><a href="#Promise异步完善" class="headerlink" title="Promise异步完善"></a>Promise异步完善</h3><p>Promise自然是为了解决异步问题的，下面示例，应该在两秒后输出信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let promise &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        resolve(&#39;data&#39;)</span><br><span class="line">    &#125;,2000)</span><br><span class="line">&#125;);</span><br><span class="line">promise.then((data)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上述代码在实例化一个 Promise的构造函数时，会在setTimeout逻辑中调用resolve,也就是说，2s后才会调用resolve方法，更改Promise实例状态。但是前面then方法中的onfulfilled 是同步执行的。我们可以先在状态( status )为pending时把开发者传进来的onfulfilled 方法存起来，再在resolve方法中执行即可。</p>
<p>同时，将resolve和reject方法放入队列中（暂时用setTimeout）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">将resolve和reject的执行放到任务队列中，暂时先用setTimeout实现</span><br><span class="line">function Promise1(executor)&#123;</span><br><span class="line">    this.status &#x3D; &#39;pending&#39;;</span><br><span class="line">    this.value &#x3D; null;</span><br><span class="line">    this.reason &#x3D; null;</span><br><span class="line">    this.onFulfilledFunc &#x3D; Function.prototype;</span><br><span class="line">    this.onrejectedFunc &#x3D; Function.prototype;</span><br><span class="line">    const resolve &#x3D; (value)&#x3D;&gt;&#123;</span><br><span class="line">        &#x2F;&#x2F; 判断传入元素是否为 Promise 值， 如果是， 则状态改变必须等待前一个状态改变后再进行改变</span><br><span class="line">        if(value instanceof Promise1)&#123;</span><br><span class="line">            return value.then(resolve,reject)</span><br><span class="line">        &#125;</span><br><span class="line">        setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">            if(this.status &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">                this.value &#x3D; value;</span><br><span class="line">                this.status &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">                this.onFulfilledFunc(this.value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    const reject &#x3D; (reason) &#x3D;&gt;&#123;</span><br><span class="line">        setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">            if(this.status &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">                this.reason &#x3D; reason;</span><br><span class="line">                this.status &#x3D; &#39;rejected&#39;;</span><br><span class="line">                this.onrejectedFunc(this.reason)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;;</span><br><span class="line">    executor(resolve,reject)</span><br><span class="line">&#125;;</span><br><span class="line">Promise1.prototype.then &#x3D; function(onfulfilled,onrejected)&#123;</span><br><span class="line">    onfulfilled &#x3D; typeof onfulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onfulfilled : data&#x3D;&gt;data</span><br><span class="line">    onrejected &#x3D; typeof onrejected &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onrejected : error&#x3D;&gt;&#123;throw error&#125;</span><br><span class="line">    if(this.status &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;)&#123;</span><br><span class="line">        onfulfilled(this.value)</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    if(this.status &#x3D;&#x3D;&#x3D; &#39;rejected&#39;)&#123;</span><br><span class="line">        rejected(this.reason)</span><br><span class="line">    &#125;;</span><br><span class="line">    if(this.status &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">        this.onFulfilledFunc&#x3D; onfulfilled;</span><br><span class="line">        this.onrejectedFunc &#x3D; onrejected;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">let promise &#x3D; new Promise1((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">    resolve(&#39;data&#39;)</span><br><span class="line">&#125;)</span><br><span class="line">promise.then(data&#x3D;&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;);</span><br><span class="line">console.log(1)</span><br></pre></td></tr></table></figure>
<h3 id="Promise细节完善"><a href="#Promise细节完善" class="headerlink" title="Promise细节完善"></a>Promise细节完善</h3><p>同样，以实例为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">继续完善，在Promise实例状态可以添加多个then方法</span><br><span class="line">    let promise &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">        setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">            resolve(&#39;data&#39;)</span><br><span class="line">        &#125;,2000)</span><br><span class="line">    &#125;);</span><br><span class="line">    promise.then((data)&#x3D;&gt;&#123;</span><br><span class="line">        console.log(&#96;1:$&#123;data&#125;&#96;)</span><br><span class="line">    &#125;);</span><br><span class="line">    promise.then((data)&#x3D;&gt;&#123;</span><br><span class="line">        console.log(&#96;2:$&#123;data&#125;&#96;)</span><br><span class="line">    &#125;)</span><br><span class="line">    应该输出1:data,2:data</span><br></pre></td></tr></table></figure>
<p>为了实现这个功能，我们可以将then方法中的onFulfilled储存到一个数组中。代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;将所有then中的方法中的onFulfilledFunc储存到一个数组中，在当前Promise中依次执行数组内的方法即可。</span><br><span class="line">    function Promise1(executor) &#123;</span><br><span class="line">        this.status &#x3D; &quot;pending&quot;;</span><br><span class="line">        this.reason &#x3D; null;</span><br><span class="line">        this.value &#x3D; null;</span><br><span class="line">        this.onFulfilledArray &#x3D; [];</span><br><span class="line">        this.onRejectedArray &#x3D; [];</span><br><span class="line">        const resolve &#x3D; (value) &#x3D;&gt; &#123;</span><br><span class="line">            if(value instanceof Promise1)&#123;</span><br><span class="line">                return value.then(resolve,reject)</span><br><span class="line">            &#125;</span><br><span class="line">            if (this.status &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    this.value &#x3D; value;</span><br><span class="line">                    this.status &#x3D; &#39;fulfilled&#39;;</span><br><span class="line">                    this.onFulfilledArray.forEach((func) &#x3D;&gt; &#123;</span><br><span class="line">                        func(value)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        const reject &#x3D; (reason) &#x3D;&gt; &#123;</span><br><span class="line">            if (this.status &#x3D;&#x3D;&#x3D; &#39;pending&#39;) &#123;</span><br><span class="line">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                    this.status &#x3D; &#39;rejected&#39;;</span><br><span class="line">                    this.reason &#x3D; reason;</span><br><span class="line">                    this.onRejectedArray.forEach((func) &#x3D;&gt; &#123;</span><br><span class="line">                        func(reason)</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        try&#123;</span><br><span class="line">            executor(resolve,reject)</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Promise1.prototype.then &#x3D; function(onfulfilled,onrejected)&#123;</span><br><span class="line">        onfulfilled &#x3D; typeof onfulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39;? onfulfilled:data&#x3D;&gt;data</span><br><span class="line">        onrejected &#x3D; typeof onrejected &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onrejected:error &#x3D;&gt;&#123;throw error&#125;</span><br><span class="line">        if(this.status &#x3D;&#x3D;&#x3D; &#39;fulfilled&#39;)&#123;</span><br><span class="line">            onfulfilled(this.value)</span><br><span class="line">        &#125;;</span><br><span class="line">        if(this.status &#x3D;&#x3D;&#x3D; &#39;rejected&#39;)&#123;</span><br><span class="line">            onrejected(this.reason)</span><br><span class="line">        &#125;;</span><br><span class="line">        if(this.status &#x3D;&#x3D;&#x3D; &#39;pending&#39;)&#123;</span><br><span class="line">            this.onFulfilledArray.push(onfulfilled);</span><br><span class="line">            this.onRejectedArray.push(onrejected)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    let promise &#x3D; new Promise1((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">        setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">            resolve(&#39;data&#39;)</span><br><span class="line">        &#125;,2000)</span><br><span class="line">    &#125;);</span><br><span class="line">    promise.then((data)&#x3D;&gt;&#123;</span><br><span class="line">        console.log(&#96;1:$&#123;data&#125;&#96;)</span><br><span class="line">    &#125;);</span><br><span class="line">    promise.then((data)&#x3D;&gt;&#123;</span><br><span class="line">        console.log(&#96;2:$&#123;data&#125;&#96;)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>到此为止《初步实现了基本的Promsie，同时还有很多功能没有实现，比如Promise then的链式调用效果、Promise.all（）等方法。</p>
<h3 id="Promise-all实现"><a href="#Promise-all实现" class="headerlink" title="Promise.all实现"></a>Promise.all实现</h3><p>MDN上对于Promise all的解释是这样的: Promise all(iterable)方法返回一个Promise实例，此实例在iterable参数内的所有Promise实例都“完成”( resolved)或数中不包含 Promise实例时完成回调(resolve);如果参数中的Promise实例有一个失败(rejected)，则此实例回调失败( reject),失败原因是第一个Promise实例失败的原因。</p>
<p>下面仍然先通过一个例子来体会一下 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let promise1 &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        resolve(&#39;hello&#39;)</span><br><span class="line">    &#125;,2000)</span><br><span class="line">&#125;);</span><br><span class="line">let promise2 &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class="line">        resolve(&#39;hello,too&#39;)</span><br><span class="line">    &#125;,2000)</span><br><span class="line">&#125;);</span><br><span class="line">Promise.all([promise1,promise2]).then((data)&#x3D;&gt;&#123;</span><br><span class="line">    console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>执行上述代码，打印出([‘hello’,’hello too’])<br>Promise.all代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Promise1.all &#x3D; function (promiseArr) &#123;</span><br><span class="line">    &#x2F;&#x2F;对promiseArr类型进行判断，如果不是数组则抛错</span><br><span class="line">    if (!Array.isArray(promiseArr)) &#123;</span><br><span class="line">        throw new TypeError(&#39;出错了&#39;)</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    return new Promise1((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            let len &#x3D; promiseArr.length;</span><br><span class="line">            let resultArr &#x3D; [];</span><br><span class="line">            for(let i &#x3D; 0;i &lt; len;i++)&#123;</span><br><span class="line">                promiseArr[i].then((data)&#x3D;&gt;&#123;</span><br><span class="line">                    resultArr.push(data);</span><br><span class="line">                    if(resultArr.length &#x3D;&#x3D;&#x3D; len)&#123;</span><br><span class="line">                        resolve(resultArr)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-race-实现"><a href="#Promise-race-实现" class="headerlink" title="Promise.race()实现"></a>Promise.race()实现</h3><p>Promse.race就是赛跑的意思，说白了，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。<br>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#39;success&#39;)</span><br><span class="line">  &#125;,1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let p2 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    reject(&#39;failed&#39;)</span><br><span class="line">  &#125;, 500)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Promise.race([p1, p2]).then((result) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(result)</span><br><span class="line">&#125;).catch((error) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(error)  &#x2F;&#x2F; 打开的是 &#39;failed&#39;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>实现代码与Promise.all类似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Promise1.race &#x3D; function(promiseArr)&#123;</span><br><span class="line">    if(!Array.isArray(promiseArr))&#123;</span><br><span class="line">        throw new TypeError(&#39;请输入数组&#39;)</span><br><span class="line">    &#125;;</span><br><span class="line">    return new Promise1((resolve,reject)&#x3D;&gt;&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            let len &#x3D; promiseArr.length;</span><br><span class="line">            for(let i &#x3D; 0;i &lt; len;i++)&#123;</span><br><span class="line">                promiseArr[i].then(resolve,reject)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line">            reject(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/03/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%89%8B%E5%86%99promise/" data-id="cknvroz7i000bvotjhir0bbfc" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-亲爱的排序算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/02/%E4%BA%B2%E7%88%B1%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="article-date">
  <time datetime="2021-03-02T02:24:25.000Z" itemprop="datePublished">2021-03-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>►<a class="article-category-link" href="/categories/JavaScript/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">排序算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/02/%E4%BA%B2%E7%88%B1%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">亲爱的排序算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><ol>
<li>如果遇到相等的值不进行交换，那这种排序方式是稳定的排序方式</li>
<li>比较相邻的两个元素，如果前一个比后一个大，则交换位置。</li>
<li>比较完第一轮的时候，最后一个元素是最大的元素。</li>
<li>这时候最后一个元素是最大的，所以最后一个元素就不需要参与比较大小。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;冒泡排序</span><br><span class="line">function maoPao(arr)&#123;</span><br><span class="line">    let len &#x3D; arr.length;</span><br><span class="line">    &#x2F;&#x2F;比较相邻的元素，第一轮比到最后的时候，最后一个自然是最大&#x2F;最小，就不用参与比较</span><br><span class="line">    for(let i &#x3D; 0;i &lt; len-1;i++)&#123;</span><br><span class="line">        for(let j &#x3D; 0;j &lt; len-1-i;j++)&#123;</span><br><span class="line">            if(arr[j] &gt; arr[j+1])&#123;</span><br><span class="line">                [arr[j],arr[j+1]] &#x3D; [arr[j+1],arr[j]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return arr</span><br><span class="line">&#125;;</span><br><span class="line">let arr1 &#x3D; [2,5,1,7,8,6];</span><br><span class="line">console.log(maoPao(arr1))</span><br></pre></td></tr></table></figure>
冒泡排序时间复杂度，最好是O(n)，最差是O(n^2),稳定性较好，稳定</li>
</ol>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序由于排序效率在同为O(N*logN)的几种排序方法中效率较高，因此经常被采用，其思想是分治。快速排序是一种既不浪费空间又可以快一点的排序算法。</p>
<p>步骤：</p>
<ol>
<li>先从数列中取出一个数作为“基准”。</li>
<li>分区过程：将比这个“基准”大的数全放到“基准”的右边，小于或等于“基准”的数全放到“基准”的左边。</li>
<li>再对左右区间重复第二步，直到各区间只有一个数</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;快速排序</span><br><span class="line">&#x2F;&#x2F;借助分冶思想，以一个数位基准，大于这个数的放一边，小于这个数的放一边，直到区间值为1为止</span><br><span class="line">function quickSort(arr)&#123;</span><br><span class="line">    &#x2F;&#x2F;递归条件</span><br><span class="line">    if(arr.length &lt;&#x3D; 1)&#123;</span><br><span class="line">        return arr;</span><br><span class="line">    &#125;;</span><br><span class="line">    let left &#x3D; [];</span><br><span class="line">    let right &#x3D; [];</span><br><span class="line">    &#x2F;&#x2F;基准值</span><br><span class="line">    let start &#x3D; arr.shift();</span><br><span class="line">    for(let value of arr)&#123;</span><br><span class="line">        if(value &gt; start)&#123;</span><br><span class="line">            right.push(value)</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            left.push(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;基准左边的值</span><br><span class="line">    let l &#x3D; quickSort(left);</span><br><span class="line">    &#x2F;&#x2F;基准右边的值</span><br><span class="line">    let r &#x3D; quickSort(right);</span><br><span class="line">    &#x2F;&#x2F;不要忘了基准自己</span><br><span class="line">    return l.concat(start,r)</span><br><span class="line">&#125;</span><br><span class="line">let arr1 &#x3D; [2,5,1,7,8,6];</span><br><span class="line">console.log(quickSort(arr1))</span><br></pre></td></tr></table></figure>
<p>快速排序时间复杂度最差是O(n^2),最好是O(nlogn)，不稳定</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。将第一个元素当成有序序列。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;插入排序</span><br><span class="line">function insertSort(arr) &#123;</span><br><span class="line">    let len &#x3D; arr.length;</span><br><span class="line">    &#x2F;&#x2F;以第一个为有序，从i&#x3D;1开始</span><br><span class="line">    for (let i &#x3D; 1; i &lt; len; i++) &#123;</span><br><span class="line">        let j &#x3D; i - 1;</span><br><span class="line">        if (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">            let temp &#x3D; arr[i];</span><br><span class="line">            while (j &gt;&#x3D; 0 &amp;&amp; temp &lt; arr[j]) &#123;</span><br><span class="line">                arr[j + 1] &#x3D; arr[j];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;;</span><br><span class="line">            arr[j + 1] &#x3D; temp</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line">let arr1 &#x3D; [2, 5, 1, 7, 8, 6];</span><br><span class="line">console.log(insertSort(arr1))</span><br></pre></td></tr></table></figure>
<p>插入排序时间复杂度最差是O(n^2),最好是O(n)，稳定</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是插入排序的一种又称“缩小增量排序”，是直接插入排序算法的一种更高效的改进版本。</p>
<p>算法先将要排序的一组数按某个增量d（n/2,n为要排序数的个数）分成若干组，每组中记录的下标相差d.对每组中全部元素进行直接插入排序，然后再用一个较小的增量（d/2）对它进行分组，在每组中再进行直接插入排序。当增量减到1时，进行直接插入排序后，排序完成。本质还是插入。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;希尔排序</span><br><span class="line">function shellSort(arr)&#123;</span><br><span class="line">    let len &#x3D; arr.length;</span><br><span class="line">    for(let gap &#x3D; Math.floor(len&#x2F;2);gap &gt;&#x3D; 1;gap &#x3D; Math.floor(gap&#x2F;2))&#123;</span><br><span class="line">        &#x2F;&#x2F; 内层循环与插入排序的写法基本一致，只是每次移动的步长变为 gap</span><br><span class="line">        for(let i &#x3D; gap;i &lt; len;i++)&#123;</span><br><span class="line">            let j &#x3D; i-gap;</span><br><span class="line">            if(arr[i] &lt; arr[j])&#123;</span><br><span class="line">                let temp &#x3D; arr[i]</span><br><span class="line">                while(j&gt;&#x3D;0 &amp;&amp; arr[j] &gt; temp)&#123;</span><br><span class="line">                    arr[j+gap] &#x3D; arr[j];</span><br><span class="line">                    j -&#x3D; gap;</span><br><span class="line">                &#125;;</span><br><span class="line">                arr[j+gap] &#x3D; temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    return arr</span><br><span class="line">&#125;</span><br><span class="line">let arr1 &#x3D; [2, 5, 1, 7, 8, 6];</span><br><span class="line">console.log(shellSort(arr1))</span><br></pre></td></tr></table></figure>
<p>插入排序时间复杂度最差是O(n^2),最好是O(n)，不稳定</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>把一个有n个记录的无序文件看成是由n个长度为1的有序子文件组成的文件，然后进行两两归并</p>
<p>本质是分冶，先分再合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function mergeSort(arr)&#123;</span><br><span class="line">        let len &#x3D; arr.length;</span><br><span class="line">        if(arr.length &lt;&#x3D; 1)&#123;</span><br><span class="line">            return arr</span><br><span class="line">        &#125;</span><br><span class="line">        let mid &#x3D; Math.floor(len&#x2F;2);</span><br><span class="line">        let left &#x3D; arr.slice(0,mid);</span><br><span class="line">        let right &#x3D; arr.slice(mid,len);</span><br><span class="line">        let l &#x3D;mergeSort(left);</span><br><span class="line">        let r &#x3D; mergeSort(right);</span><br><span class="line">        return merge(l,r)</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    function merge(left,right)&#123;</span><br><span class="line">        let result &#x3D; [];</span><br><span class="line">        while(left.length &amp;&amp; right.length)&#123;</span><br><span class="line">            if(left[0] &lt;&#x3D; right[0])&#123;</span><br><span class="line">                result.push(left.shift())</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                result.push(right.shift())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        while(left.length)&#123;</span><br><span class="line">            result.push(left.shift())</span><br><span class="line">        &#125;;</span><br><span class="line">        while(right.length)&#123;</span><br><span class="line">            result.push(right.shift())</span><br><span class="line">        &#125;;</span><br><span class="line">        return result</span><br><span class="line">    &#125;;</span><br><span class="line">    let arr1 &#x3D; [2, 5, 1, 7, 8, 6];</span><br><span class="line">    console.log(mergeSort(arr1))</span><br></pre></td></tr></table></figure>
<p>快速排序时间复杂度最差是O(nlogn),最好是O(nlogn)，稳定</p>
<h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><p>在第i次选择操作中，通过n-i次键值间比较，从n-i+1个记录中选出键值最小的记录，并和第i（1小于等于1小于等于n-1）个记录交换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;直接选择排序</span><br><span class="line">function selectSort(arr1)&#123;</span><br><span class="line">    let len &#x3D; arr1.length;</span><br><span class="line">    for(let i &#x3D; 0;i &lt; len;i++)&#123;</span><br><span class="line">        let min &#x3D; Math.max(...arr1.slice(i));</span><br><span class="line">        let index &#x3D; arr1.indexOf(min);</span><br><span class="line">        [arr1[i],arr1[index]] &#x3D; [arr1[index],arr1[i]]</span><br><span class="line">    &#125;;</span><br><span class="line">    return arr1</span><br><span class="line">&#125;</span><br><span class="line">let arr1 &#x3D; [2, 5, 1, 7, 8, 6];</span><br><span class="line">console.log(selectSort(arr1))</span><br></pre></td></tr></table></figure>
<p>插入排序时间复杂度最差是O(n^2),最好是O(n^2),不稳定</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/02/%E4%BA%B2%E7%88%B1%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" data-id="cknvroz7g0009votj0im24x0e" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-原型对象和继承" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/01/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%BB%A7%E6%89%BF/" class="article-date">
  <time datetime="2021-03-01T12:36:48.000Z" itemprop="datePublished">2021-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>►<a class="article-category-link" href="/categories/JavaScript/%E5%AF%B9%E8%B1%A1/">对象</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/01/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%BB%A7%E6%89%BF/">原型对象和继承</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>结合自己的理解以及相关资料，将原型对象和继承的知识点记录如下：</p>
<h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><ol>
<li>原型对象、构造函数、实例之间的关系</li>
</ol>
<p>在 js 中我们是使用构造函数来新建一个对象的， 每一个构造函数的内部都有一个 prototype属性值， 它指向函数的原型对象，所以这个属性值是一个对象， 这个对象包含了可以由该构造函数的所有实例共享的属性和方法。因此在使用prototype属性之后，就可以将实例共享的属性和函数抽离出构造函数，将他们添加在prototype属性中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Person(name,age)&#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age</span><br><span class="line">    &#125;</span><br><span class="line">Person.prototype.weight &#x3D; function()&#123;</span><br><span class="line">        console.log(this.name)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>实例共享的weight()函数就被添加在了Person.prototype属性上。</p>
<p>构造函数的prototype属性会指向它的原型对象，而通过构造函数可以生成具体的实例。三者之间的关系如何？</p>
<p>每一个构造函数的内部都有一个 prototype属性，在默认的情况下，所有的原型对象都会增加一个constructor属性，指向prototype所在的函数，即构造函数。</p>
<p>当我们通过new调用构造函数创建一个实例时，实例会具有一个__proto__属性，指向构造函数的原型对象，因此，__proto__属性可以看成是一个连接实例与构造函数的原型对象的桥梁。</p>
<p>下面这段代码为构造函数的原型对象添加了3个属性，同时生成两个实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;;</span><br><span class="line">Person.prototype.name &#x3D; &quot;xiaobai&quot;;</span><br><span class="line">Person.prototype.age &#x3D; 18;</span><br><span class="line">Person.prototype.sayname &#x3D; function()&#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;;</span><br><span class="line">var person1 &#x3D; new Person();</span><br><span class="line">var person2 &#x3D; new Person();</span><br></pre></td></tr></table></figure>
<p>以构造函数Person为例来看，构造函数原型对象和实例之间的关系<br><img src="/2021/03/01/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%BB%A7%E6%89%BF/pic1.png"><br>2. 原型链<br>对象的每个实例都有__proto__属性，指向构造函数的原型对象，而原型对象上同样也是存在着一个__proto__属性指向上一级构造函数的原型对象，就这样层层往上，直到最上层某个原型对象为 Null.</p>
<p>在JS中几乎所有的对象都有__proto__属性，由__proto__属性连接而成的链路构成了JS的原型链，原型链的顶端是Object.prototype，他的__proto__属性为Null</p>
<p>原型链的特点:<br>1）由于原型链的存在，属性查找的过程不再是查找自身的原型对象，而是会沿着整个原型链一直向上，直到追溯到Object.prototype，再找不到就返回undefined</p>
<p>由于上述特点，在生成自定义对象的实例时，也可以调用某些未在自定义构造函数上的函数，如toString()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;;</span><br><span class="line">var p &#x3D; new Person();</span><br><span class="line">p.toString()</span><br><span class="line">&#x2F;&#x2F;[object object],实际调用的是Object.prototype.toString()函数</span><br></pre></td></tr></table></figure>
<p>2)由于属性的查找会经历整个链路，因此查找的链路越长，对性能影响越大。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>ES5继承方式有多种，包括原型链继承、构造继承、复制继承、组合继承、寄生组合继承等,各有优缺点。下面实现几种继承（ES5）</p>
<ol>
<li>原型链继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;&#x2F;定义一个父类Animal</span><br><span class="line">function Animal(name) &#123;</span><br><span class="line">    &#x2F;&#x2F;属性</span><br><span class="line">    this.type &#x3D; &#39;Animal&#39;;</span><br><span class="line">    this.name &#x3D; name || &#39;动物&#39;;</span><br><span class="line">    &#x2F;&#x2F;实例函数</span><br><span class="line">    this.sleep &#x3D; function () &#123;</span><br><span class="line">        console.log(this.name + &#39;正在睡觉&#39;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;原型函数</span><br><span class="line">Animal.prototype.eat &#x3D; function (food) &#123;</span><br><span class="line">    console.log(this.name + &#39;正在吃&#39; + food)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#x2F;&#x2F;1 原型链继承</span><br><span class="line">&#x2F;&#x2F; &#x2F;&#x2F;主要思想：重写子类的prototype属性，将其指向父类的实例</span><br><span class="line">&#x2F;&#x2F; &#x2F;&#x2F;定义一个子类Cat,用于继承父类Animal,子类的实现如下；</span><br><span class="line">function Cat(name)&#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;原型继承</span><br><span class="line">Cat.prototype &#x3D; new Animal();</span><br><span class="line">&#x2F;&#x2F;关键！将Cat的构造函数指向自身</span><br><span class="line">Cat.prototype.constructor &#x3D; Cat;</span><br><span class="line">var cat &#x3D; new Cat(&#39;小猫咪&#39;);</span><br><span class="line">console.log(cat.name);</span><br><span class="line">console.log(cat.type);</span><br><span class="line">console.log(cat.sleep());</span><br><span class="line">console.log(cat.eat(&#39;鱼干&#39;))</span><br><span class="line">console.log(cat instanceof Animal)</span><br></pre></td></tr></table></figure></li>
<li>构造继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构造继承</span><br><span class="line">function Cat(name)&#123;</span><br><span class="line">    &#x2F;&#x2F;关键，通过call()函数实现Animal的实例的属性和函数的继承</span><br><span class="line">    Animal.call(this);</span><br><span class="line">    this.name &#x3D; name || &#39;tony&#39;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">var p1 &#x3D; new Cat(&#39;猫猫&#39;);</span><br><span class="line">console.log(p1.name);</span><br><span class="line">console.log(p1.type);</span><br><span class="line">console.log(p1.sleep());</span><br><span class="line">&#x2F;&#x2F;Uncaught TypeError: p1.eat is not a function</span><br><span class="line">console.log(p1.eat())</span><br><span class="line">&#x2F;&#x2F;可以发现，子类可以正常调用父类的实例函数，而无法调用父类原型对象上的函数</span><br></pre></td></tr></table></figure></li>
<li>组合继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">组合继承</span><br><span class="line">组合继承的主要思想是组合了构造继承和原型继承两种方法，一方面在子类的构造函数中通过call()函数</span><br><span class="line">调用父类的构造函数，将父类的实例的属性和函数绑定到子类的this中；</span><br><span class="line">另一方面通过改变子类的prototype属性，继承父类的原型对象上的属性和函数</span><br><span class="line">function Cat(name) &#123;</span><br><span class="line">    &#x2F;&#x2F;通过构造函数继承实例的属性和函数</span><br><span class="line">    Animal.call(this);</span><br><span class="line">    this.name &#x3D; name || &#39;hania&#39;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;通过原型继承原型对象上的属性和函数</span><br><span class="line">Cat.prototype &#x3D; new Animal();</span><br><span class="line">Cat.prototype.constructor &#x3D; Cat;</span><br><span class="line">var cat &#x3D; new Cat(&#39;shishi&#39;);</span><br><span class="line">console.log(cat.name);</span><br><span class="line">console.log(cat.sleep());</span><br><span class="line">console.log(cat.eat(&#39;好吃的&#39;))      </span><br></pre></td></tr></table></figure></li>
<li>寄生式组合继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;组合继承的缺点是父类的实例属性回绑定两次</span><br><span class="line">&#x2F;&#x2F;针对上述缺点，有了寄生组合继承</span><br><span class="line">&#x2F;&#x2F;在进行子类的prototype属性的设置时，可以去掉父类实例的属性和函数</span><br><span class="line">&#x2F;&#x2F;子类</span><br><span class="line">function Cat(name) &#123;</span><br><span class="line">    Animal.call(this);</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;设置任意的函数Super</span><br><span class="line">var Super &#x3D; function () &#123; &#125;;</span><br><span class="line">&#x2F;&#x2F;关键 Super()函数的原型指向父类Animal的原型，去掉父类的实例属性</span><br><span class="line">Super.prototype &#x3D; Animal.prototype;</span><br><span class="line">Cat.prototype &#x3D; new Super();</span><br><span class="line">Cat.prototype.constructor &#x3D; Cat;</span><br><span class="line">var cat &#x3D; new Cat(&#39;shishi&#39;);</span><br><span class="line">console.log(cat.name);</span><br><span class="line">console.log(cat.sleep());</span><br><span class="line">console.log(cat.eat(&#39;好吃的ya&#39;))</span><br></pre></td></tr></table></figure>
<h2 id="ES6中对象及继承"><a href="#ES6中对象及继承" class="headerlink" title="ES6中对象及继承"></a>ES6中对象及继承</h2></li>
<li>ES6中引入了Class(类)的概念，通过class关键字定义类的名字，然后在constructor构造函数中定义实例属性，原型属性在class内部直接声明并赋值，原型函数的声明与构造函数处于同一层级，并且省略function关键字<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Cat&#123;</span><br><span class="line">    &#x2F;&#x2F;原型属性</span><br><span class="line">    publicCount &#x3D; 1;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        &#x2F;&#x2F;实例属性</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;原型函数</span><br><span class="line">    getName()&#123;</span><br><span class="line">        return this.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p &#x3D; new Cat(&#39;shishi&#39;,12)</span><br><span class="line">console.log(p.getName())</span><br></pre></td></tr></table></figure></li>
<li>class继承<br>ES6中新增了extends关键字，可以快速实现类的继承<br>在子类的constructor构造函数中，需要首先调用super()函数执行父类的构造函数，再执行子类的函数修饰this.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ES6class继承</span><br><span class="line">class Dad&#123;</span><br><span class="line">    constructor(type)&#123;</span><br><span class="line">        this.type &#x3D; type</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">class Son extends Dad&#123;</span><br><span class="line">    constructor(type,name)&#123;</span><br><span class="line">        super(type);</span><br><span class="line">        this.name &#x3D; name</span><br><span class="line">    &#125;;</span><br><span class="line">    getName()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let son &#x3D; new Son(&#39;mimi&#39;,&#39;Tom&#39;);</span><br><span class="line">console.log(son.type)</span><br></pre></td></tr></table></figure>
//关于ES6的知识学习阮一峰老师的书</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/01/%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%BB%A7%E6%89%BF/" data-id="cknvroz9b0058votjaqbzgl4g" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-剑指Offer32-从上到下打印二叉树（3）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/01/%E5%89%91%E6%8C%87Offer32-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%883%EF%BC%89/" class="article-date">
  <time datetime="2021-03-01T08:41:11.000Z" itemprop="datePublished">2021-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/">力扣刷题</a>►<a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/01/%E5%89%91%E6%8C%87Offer32-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%883%EF%BC%89/">剑指Offer32-从上到下打印二叉树（3）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">剑指Offer32-从上到下打印二叉树（3）</a></p>
<p>请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<p>例如:<br>给定二叉树: [3,9,20,null,null,15,7]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.left &#x3D; this.right &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;number[][]&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var levelOrder &#x3D; function(root) &#123;</span><br><span class="line">    if(!root)&#123;</span><br><span class="line">        return [];</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;层序遍历</span><br><span class="line">    let queue &#x3D; [root];</span><br><span class="line">    let res &#x3D; [];</span><br><span class="line">    let level &#x3D; 0;</span><br><span class="line">    while(queue.length)&#123;</span><br><span class="line">        let len &#x3D; queue.length;</span><br><span class="line">        res[level] &#x3D; [];</span><br><span class="line">        while(len)&#123;</span><br><span class="line">            let node &#x3D; queue.shift();</span><br><span class="line">            res[level].push(node.val);</span><br><span class="line">            if(node.left)&#123;</span><br><span class="line">                queue.push(node.left)</span><br><span class="line">            &#125;;</span><br><span class="line">            if(node.right)&#123;</span><br><span class="line">                queue.push(node.right)</span><br><span class="line">            &#125;;</span><br><span class="line">            len--</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F;多加了一个判断条件，将数组进行翻转</span><br><span class="line">        if(level % 2)&#123;</span><br><span class="line">            res[level].reverse()</span><br><span class="line">        &#125;;</span><br><span class="line">        level++;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">    return res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/01/%E5%89%91%E6%8C%87Offer32-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%883%EF%BC%89/" data-id="cknvroz7q000tvotjhljw4olc" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-剑指Offer33-二叉搜索树的后序遍历序列" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/03/01/%E5%89%91%E6%8C%87Offer33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/" class="article-date">
  <time datetime="2021-03-01T03:37:26.000Z" itemprop="datePublished">2021-03-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/">力扣刷题</a>►<a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/03/01/%E5%89%91%E6%8C%87Offer33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/">剑指Offer33-二叉搜索树的后序遍历序列</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/">剑指Offer33-二叉搜索树的后序遍历序列</a></p>
<p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。</p>
<p>参考以下这颗二叉搜索树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  2   6</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,6,3,2,5]</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">输入: [1,3,2,6,5]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p>注释及详细代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; postorder</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var verifyPostorder &#x3D; function(postorder) &#123;</span><br><span class="line">    &#x2F;&#x2F;递归</span><br><span class="line">    &#x2F;&#x2F;利用二叉搜索树的特性，右节点值比根节点大</span><br><span class="line">    &#x2F;&#x2F;后序遍历是左--右--根，先找到根节点</span><br><span class="line">    &#x2F;&#x2F;找到第一个大于根节点的进行左右节点划分</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;如果长度小于等于1，直接为true</span><br><span class="line">    if(postorder.length &lt;&#x3D; 1)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;;</span><br><span class="line">    let len &#x3D; postorder.length;</span><br><span class="line">    let root &#x3D; postorder[len-1];</span><br><span class="line">    var index;</span><br><span class="line">    for(let i &#x3D; 0;i &lt; len;i++)&#123;</span><br><span class="line">        if(postorder[i] &gt;&#x3D; root)&#123;</span><br><span class="line">            index &#x3D; i;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    let right &#x3D; postorder.slice(index,len-1);</span><br><span class="line">    let left &#x3D; postorder.slice(0,index);</span><br><span class="line">    &#x2F;&#x2F;数组api every的用法</span><br><span class="line">    &#x2F;&#x2F;判断是不是右子树的点都大于根节点同时左子树节点小于根节点</span><br><span class="line">    let res &#x3D;right.every((item) &#x3D;&gt; item &gt; root) &amp;&amp; left.every(item &#x3D;&gt; item &lt; root);</span><br><span class="line">    &#x2F;&#x2F;如果是，继续递归</span><br><span class="line">    if(res)&#123;</span><br><span class="line">        return verifyPostorder(postorder.slice(0,index)) &amp;&amp; verifyPostorder(postorder.slice(index,len-1))</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/01/%E5%89%91%E6%8C%87Offer33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/" data-id="cknvroz7t0013votj46dwdmc5" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-力扣105-从前序与中序遍历序列构造二叉树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/02/28/%E5%8A%9B%E6%89%A3105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/" class="article-date">
  <time datetime="2021-02-28T11:51:58.000Z" itemprop="datePublished">2021-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/">力扣刷题</a>►<a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/28/%E5%8A%9B%E6%89%A3105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/">力扣105-从前序与中序遍历序列构造二叉树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">力扣105-从前序与中序遍历序列构造二叉树</a></p>
<p>根据一棵树的前序遍历与中序遍历构造二叉树。你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>前序遍历 preorder = [3,9,20,15,7]</p>
<p>中序遍历 inorder = [9,3,15,20,7]</p>
<p>返回如下的二叉树：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val, left, right) &#123;</span><br><span class="line"> *     this.val &#x3D; (val&#x3D;&#x3D;&#x3D;undefined ? 0 : val)</span><br><span class="line"> *     this.left &#x3D; (left&#x3D;&#x3D;&#x3D;undefined ? null : left)</span><br><span class="line"> *     this.right &#x3D; (right&#x3D;&#x3D;&#x3D;undefined ? null : right)</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;number[]&#125; preorder</span><br><span class="line"> * @param &#123;number[]&#125; inorder</span><br><span class="line"> * @return &#123;TreeNode&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var buildTree &#x3D; function(preorder, inorder) &#123;</span><br><span class="line">    &#x2F;&#x2F;非常非常暴力的解法....没有一点优化...</span><br><span class="line">    &#x2F;&#x2F;前序是根-左-右，中序是左-右-根</span><br><span class="line">    &#x2F;&#x2F;所以先找到根节点，划分出左右子树，然后递归构建左右子树</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;递归出口</span><br><span class="line">    if(preorder.length &#x3D;&#x3D;&#x3D; 0)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;前序遍历的第一个值肯定为根节点</span><br><span class="line">    let root &#x3D; new TreeNode(preorder[0]);</span><br><span class="line">    let mid &#x3D; inorder.indexOf(preorder[0]);</span><br><span class="line">    root.left &#x3D; buildTree(preorder.slice(1,mid+1),inorder.slice(0,mid));</span><br><span class="line">    root.right &#x3D; buildTree(preorder.slice(mid+1),inorder.slice(mid+1));</span><br><span class="line">    return root;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/28/%E5%8A%9B%E6%89%A3105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/" data-id="cknvroz82001pvotja3k409ss" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-力扣110-平衡二叉树" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2021/02/28/%E5%8A%9B%E6%89%A3110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" class="article-date">
  <time datetime="2021-02-28T03:38:36.000Z" itemprop="datePublished">2021-02-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/">力扣刷题</a>►<a class="article-category-link" href="/categories/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91/">二叉树</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2021/02/28/%E5%8A%9B%E6%89%A3110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/">力扣110-平衡二叉树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/balanced-binary-tree/">力扣110-平衡二叉树</a></p>
<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>
<p>本题中，一棵高度平衡二叉树定义为：<br>一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。</p>
<p>示例:给定二叉树[1,2,2,3,3,null,null,4,4]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure>
<p> 返回false</p>
<p> 递归方法：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * function TreeNode(val) &#123;</span><br><span class="line"> *     this.val &#x3D; val;</span><br><span class="line"> *     this.left &#x3D; this.right &#x3D; null;</span><br><span class="line"> * &#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param &#123;TreeNode&#125; root</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">var isBalanced &#x3D; function(root) &#123;</span><br><span class="line">    if(!root)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;;</span><br><span class="line">    let left &#x3D; dfs(root.left);</span><br><span class="line">    let right &#x3D; dfs(root.right);</span><br><span class="line">    &#x2F;&#x2F;深度差大于1返回false</span><br><span class="line">    if(Math.abs(left - right) &gt; 1)&#123;</span><br><span class="line">        return false</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F;递归判断</span><br><span class="line">    return isBalanced(root.left) &amp;&amp; isBalanced(root.right)</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;计算树的深度</span><br><span class="line">var dfs &#x3D; function(root)&#123;</span><br><span class="line">    if(!root)&#123;</span><br><span class="line">        return 0</span><br><span class="line">    &#125;;</span><br><span class="line">    return Math.max(dfs(root.left),dfs(root.right)) + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/28/%E5%8A%9B%E6%89%A3110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/" data-id="cknvroz85001xvotj8tdj1byx" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/5/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/7/">下一页&amp;raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/24/%E5%8A%9B%E6%89%A3377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C4/">力扣377--组合总和4</a>
          </li>
        
          <li>
            <a href="/2021/04/24/%E5%8A%9B%E6%89%A3518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A22/">力扣518--零钱兑换2</a>
          </li>
        
          <li>
            <a href="/2021/04/23/%E5%8A%9B%E6%89%A3368-%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86/">力扣368--最大整除子集</a>
          </li>
        
          <li>
            <a href="/2021/04/22/offer38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/">offer38--字符串的排列</a>
          </li>
        
          <li>
            <a href="/2021/04/19/%E5%8A%9B%E6%89%A327-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/">力扣27--移除元素</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
    
  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2021 jianjian&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;2040787513@qq.com
    </div>
  </div>
</footer>
 
<script src="/jquery/jquery.min.js"></script>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
    <a href="/categories" class="mobile-nav-link">分类</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png"/>
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 
<script src="/js/is.js"></script>



  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/elevator.js"></script>

  </div>
</body>
</html>